// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.2
//   protoc               v5.28.2
// source: packages/core/src/protos/tank_definitions.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import { I18nString } from './i18n';

export const protobufPackage = 'blitzkit';

export enum TankPriceType {
  CREDITS = 0,
  GOLD = 1,
}

export function tankPriceTypeFromJSON(object: any): TankPriceType {
  switch (object) {
    case 0:
    case 'TANK_PRICE_TYPE_CREDITS':
      return TankPriceType.CREDITS;
    case 1:
    case 'TANK_PRICE_TYPE_GOLD':
      return TankPriceType.GOLD;
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum TankPriceType',
      );
  }
}

export function tankPriceTypeToJSON(object: TankPriceType): string {
  switch (object) {
    case TankPriceType.CREDITS:
      return 'TANK_PRICE_TYPE_CREDITS';
    case TankPriceType.GOLD:
      return 'TANK_PRICE_TYPE_GOLD';
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum TankPriceType',
      );
  }
}

export enum ShellType {
  AP = 0,
  APCR = 1,
  HEAT = 2,
  HE = 3,
}

export function shellTypeFromJSON(object: any): ShellType {
  switch (object) {
    case 0:
    case 'SHELL_TYPE_AP':
      return ShellType.AP;
    case 1:
    case 'SHELL_TYPE_APCR':
      return ShellType.APCR;
    case 2:
    case 'SHELL_TYPE_HEAT':
      return ShellType.HEAT;
    case 3:
    case 'SHELL_TYPE_HE':
      return ShellType.HE;
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum ShellType',
      );
  }
}

export function shellTypeToJSON(object: ShellType): string {
  switch (object) {
    case ShellType.AP:
      return 'SHELL_TYPE_AP';
    case ShellType.APCR:
      return 'SHELL_TYPE_APCR';
    case ShellType.HEAT:
      return 'SHELL_TYPE_HEAT';
    case ShellType.HE:
      return 'SHELL_TYPE_HE';
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum ShellType',
      );
  }
}

export enum ModuleType {
  VEHICLE = 0,
  ENGINE = 1,
  TRACKS = 2,
  TURRET = 3,
  GUN = 4,
}

export function moduleTypeFromJSON(object: any): ModuleType {
  switch (object) {
    case 0:
    case 'MODULE_TYPE_VEHICLE':
      return ModuleType.VEHICLE;
    case 1:
    case 'MODULE_TYPE_ENGINE':
      return ModuleType.ENGINE;
    case 2:
    case 'MODULE_TYPE_TRACKS':
      return ModuleType.TRACKS;
    case 3:
    case 'MODULE_TYPE_TURRET':
      return ModuleType.TURRET;
    case 4:
    case 'MODULE_TYPE_GUN':
      return ModuleType.GUN;
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum ModuleType',
      );
  }
}

export function moduleTypeToJSON(object: ModuleType): string {
  switch (object) {
    case ModuleType.VEHICLE:
      return 'MODULE_TYPE_VEHICLE';
    case ModuleType.ENGINE:
      return 'MODULE_TYPE_ENGINE';
    case ModuleType.TRACKS:
      return 'MODULE_TYPE_TRACKS';
    case ModuleType.TURRET:
      return 'MODULE_TYPE_TURRET';
    case ModuleType.GUN:
      return 'MODULE_TYPE_GUN';
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum ModuleType',
      );
  }
}

export enum TankClass {
  LIGHT = 0,
  MEDIUM = 1,
  HEAVY = 2,
  TANK_DESTROYER = 3,
}

export function tankClassFromJSON(object: any): TankClass {
  switch (object) {
    case 0:
    case 'TANK_CLASS_LIGHT':
      return TankClass.LIGHT;
    case 1:
    case 'TANK_CLASS_MEDIUM':
      return TankClass.MEDIUM;
    case 2:
    case 'TANK_CLASS_HEAVY':
      return TankClass.HEAVY;
    case 3:
    case 'TANK_CLASS_TANK_DESTROYER':
      return TankClass.TANK_DESTROYER;
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum TankClass',
      );
  }
}

export function tankClassToJSON(object: TankClass): string {
  switch (object) {
    case TankClass.LIGHT:
      return 'TANK_CLASS_LIGHT';
    case TankClass.MEDIUM:
      return 'TANK_CLASS_MEDIUM';
    case TankClass.HEAVY:
      return 'TANK_CLASS_HEAVY';
    case TankClass.TANK_DESTROYER:
      return 'TANK_CLASS_TANK_DESTROYER';
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum TankClass',
      );
  }
}

export enum TankType {
  RESEARCHABLE = 0,
  PREMIUM = 1,
  COLLECTOR = 2,
}

export function tankTypeFromJSON(object: any): TankType {
  switch (object) {
    case 0:
    case 'TANK_TYPE_RESEARCHABLE':
      return TankType.RESEARCHABLE;
    case 1:
    case 'TANK_TYPE_PREMIUM':
      return TankType.PREMIUM;
    case 2:
    case 'TANK_TYPE_COLLECTOR':
      return TankType.COLLECTOR;
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum TankType',
      );
  }
}

export function tankTypeToJSON(object: TankType): string {
  switch (object) {
    case TankType.RESEARCHABLE:
      return 'TANK_TYPE_RESEARCHABLE';
    case TankType.PREMIUM:
      return 'TANK_TYPE_PREMIUM';
    case TankType.COLLECTOR:
      return 'TANK_TYPE_COLLECTOR';
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum TankType',
      );
  }
}

export enum CrewType {
  COMMANDER = 0,
  RADIOMAN = 1,
  GUNNER = 2,
  DRIVER = 3,
  LOADER = 4,
}

export function crewTypeFromJSON(object: any): CrewType {
  switch (object) {
    case 0:
    case 'CREW_TYPE_COMMANDER':
      return CrewType.COMMANDER;
    case 1:
    case 'CREW_TYPE_RADIOMAN':
      return CrewType.RADIOMAN;
    case 2:
    case 'CREW_TYPE_GUNNER':
      return CrewType.GUNNER;
    case 3:
    case 'CREW_TYPE_DRIVER':
      return CrewType.DRIVER;
    case 4:
    case 'CREW_TYPE_LOADER':
      return CrewType.LOADER;
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum CrewType',
      );
  }
}

export function crewTypeToJSON(object: CrewType): string {
  switch (object) {
    case CrewType.COMMANDER:
      return 'CREW_TYPE_COMMANDER';
    case CrewType.RADIOMAN:
      return 'CREW_TYPE_RADIOMAN';
    case CrewType.GUNNER:
      return 'CREW_TYPE_GUNNER';
    case CrewType.DRIVER:
      return 'CREW_TYPE_DRIVER';
    case CrewType.LOADER:
      return 'CREW_TYPE_LOADER';
    default:
      throw new globalThis.Error(
        'Unrecognized enum value ' + object + ' for enum CrewType',
      );
  }
}

export interface TankDefinitions {
  tanks: { [key: number]: TankDefinition };
}

export interface TankDefinitions_TanksEntry {
  key: number;
  value: TankDefinition | undefined;
}

export interface TankDefinition {
  id: number;
  slug: string;
  roles: { [key: number]: number };
  fixed_camouflage: boolean;
  camouflages: number[];
  ancestors: number[];
  successors: number[];
  crew: Crew[];
  health: number;
  nation: string;
  name: I18nString | undefined;
  type: TankType;
  max_consumables: number;
  max_provisions: number;
  tier: number;
  class: TankClass;
  testing: boolean;
  deprecated: boolean;
  turrets: TurretDefinition[];
  engines: EngineDefinition[];
  tracks: TrackDefinition[];
  price: TankPrice | undefined;
  research_cost?: ResearchCost | undefined;
  speed_forwards: number;
  speed_backwards: number;
  camouflage_still: number;
  camouflage_moving: number;
  camouflage_onFire: number;
  equipment_preset: string;
  weight: number;
}

export interface TankDefinition_RolesEntry {
  key: number;
  value: number;
}

export interface ResearchCost {
  research_cost_type?:
    | { $case: 'xp'; value: number }
    | { $case: 'seasonal_tokens'; value: ResearchCostSeasonalTokens }
    | undefined;
}

export interface ResearchCostSeasonalTokens {
  season: number;
  tokens: number;
}

export interface TankPrice {
  type: TankPriceType;
  value: number;
}

export interface TrackDefinition {
  id: number;
  tier: number;
  name: I18nString | undefined;
  weight: number;
  traverse_speed: number;
  research_cost?: ResearchCost | undefined;
  dispersion_move: number;
  dispersion_traverse: number;
  resistance_hard: number;
  resistance_medium: number;
  resistance_soft: number;
  unlocks: Unlock[];
}

export interface EngineDefinition {
  id: number;
  name: I18nString | undefined;
  research_cost?: ResearchCost | undefined;
  tier: number;
  fire_chance: number;
  power: number;
  weight: number;
  unlocks: Unlock[];
}

export interface TurretDefinition {
  id: number;
  health: number;
  view_range: number;
  traverse_speed: number;
  research_cost?: ResearchCost | undefined;
  name: I18nString | undefined;
  tier: number;
  weight: number;
  guns: GunDefinition[];
  unlocks: Unlock[];
}

export interface GunDefinition {
  gun_type?:
    | { $case: 'regular'; value: GunDefinitionRegular }
    | { $case: 'auto_loader'; value: GunDefinitionAutoLoader }
    | { $case: 'auto_reloader'; value: GunDefinitionAutoReloader }
    | undefined;
}

export interface GunDefinitionRegular {
  base: GunDefinitionBase;
  extension: GunDefinitionRegularProperties;
}

export interface GunDefinitionRegularProperties {
  reload: number;
}

export interface GunDefinitionAutoLoader {
  base: GunDefinitionBase;
  extension: GunDefinitionAutoLoaderProperties;
}

export interface GunDefinitionAutoLoaderProperties {
  clip_reload: number;
  intra_clip: number;
  shell_count: number;
}

export interface GunDefinitionAutoReloader {
  base: GunDefinitionBase;
  extension: GunDefinitionAutoReloaderProperties;
}

export interface GunDefinitionAutoReloaderProperties {
  shell_reloads: number[];
  intra_clip: number;
  shell_count: number;
}

export interface GunDefinitionBase {
  id: number;
  rotation_speed: number;
  research_cost?: ResearchCost | undefined;
  weight: number;
  name: I18nString | undefined;
  tier: number;
  shells: ShellDefinition[];
  camouflage_loss: number;
  aim_time: number;
  dispersion_base: number;
  dispersion_traverse: number;
  dispersion_shot: number;
  dispersion_damaged: number;
  unlocks: Unlock[];
  shell_capacity: number;
  assault_ranges?: AssaultRanges | undefined;
}

export interface AssaultRanges {
  ranges: AssaultRange[];
  types: ShellType[];
}

export interface AssaultRange {
  distance: number;
  factor: number;
}

export interface ShellDefinition {
  id: number;
  name: I18nString;
  velocity: number;
  armor_damage: number;
  module_damage: number;
  caliber: number;
  icon: string;
  penetration: ShellPenetration;
  type: ShellType;
  normalization?: number | undefined;
  ricochet?: number | undefined;
  explosion_radius?: number | undefined;
  range: number;
}

export interface ShellPenetration {
  near: number;
  far: number;
}

export interface Unlock {
  id: number;
  type: ModuleType;
  cost: UnlockCost | undefined;
}

export interface UnlockCost {
  type: string;
  value: number;
}

export interface Crew {
  type: CrewType;
  count: number;
  substitute: CrewType[];
}

function createBaseTankDefinitions(): TankDefinitions {
  return { tanks: {} };
}

export const TankDefinitions: MessageFns<TankDefinitions> = {
  encode(
    message: TankDefinitions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    Object.entries(message.tanks).forEach(([key, value]) => {
      TankDefinitions_TanksEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TankDefinitions {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTankDefinitions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = TankDefinitions_TanksEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry1.value !== undefined) {
            message.tanks[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TankDefinitions {
    return {
      tanks: isObject(object.tanks)
        ? Object.entries(object.tanks).reduce<{
            [key: number]: TankDefinition;
          }>((acc, [key, value]) => {
            acc[globalThis.Number(key)] = TankDefinition.fromJSON(value);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: TankDefinitions): unknown {
    const obj: any = {};
    if (message.tanks) {
      const entries = Object.entries(message.tanks);
      if (entries.length > 0) {
        obj.tanks = {};
        entries.forEach(([k, v]) => {
          obj.tanks[k] = TankDefinition.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TankDefinitions>, I>>(
    base?: I,
  ): TankDefinitions {
    return TankDefinitions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TankDefinitions>, I>>(
    object: I,
  ): TankDefinitions {
    const message = createBaseTankDefinitions();
    message.tanks = Object.entries(object.tanks ?? {}).reduce<{
      [key: number]: TankDefinition;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = TankDefinition.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTankDefinitions_TanksEntry(): TankDefinitions_TanksEntry {
  return { key: 0, value: undefined };
}

export const TankDefinitions_TanksEntry: MessageFns<TankDefinitions_TanksEntry> =
  {
    encode(
      message: TankDefinitions_TanksEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== 0) {
        writer.uint32(8).uint32(message.key);
      }
      if (message.value !== undefined) {
        TankDefinition.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TankDefinitions_TanksEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTankDefinitions_TanksEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.key = reader.uint32();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = TankDefinition.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TankDefinitions_TanksEntry {
      return {
        key: isSet(object.key) ? globalThis.Number(object.key) : 0,
        value: isSet(object.value)
          ? TankDefinition.fromJSON(object.value)
          : undefined,
      };
    },

    toJSON(message: TankDefinitions_TanksEntry): unknown {
      const obj: any = {};
      if (message.key !== 0) {
        obj.key = Math.round(message.key);
      }
      if (message.value !== undefined) {
        obj.value = TankDefinition.toJSON(message.value);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<TankDefinitions_TanksEntry>, I>>(
      base?: I,
    ): TankDefinitions_TanksEntry {
      return TankDefinitions_TanksEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TankDefinitions_TanksEntry>, I>>(
      object: I,
    ): TankDefinitions_TanksEntry {
      const message = createBaseTankDefinitions_TanksEntry();
      message.key = object.key ?? 0;
      message.value =
        object.value !== undefined && object.value !== null
          ? TankDefinition.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseTankDefinition(): TankDefinition {
  return {
    id: 0,
    slug: '',
    roles: {},
    fixed_camouflage: false,
    camouflages: [],
    ancestors: [],
    successors: [],
    crew: [],
    health: 0,
    nation: '',
    name: undefined,
    type: 0,
    max_consumables: 0,
    max_provisions: 0,
    tier: 0,
    class: 0,
    testing: false,
    deprecated: false,
    turrets: [],
    engines: [],
    tracks: [],
    price: undefined,
    research_cost: undefined,
    speed_forwards: 0,
    speed_backwards: 0,
    camouflage_still: 0,
    camouflage_moving: 0,
    camouflage_onFire: 0,
    equipment_preset: '',
    weight: 0,
  };
}

export const TankDefinition: MessageFns<TankDefinition> = {
  encode(
    message: TankDefinition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.slug !== '') {
      writer.uint32(18).string(message.slug);
    }
    Object.entries(message.roles).forEach(([key, value]) => {
      TankDefinition_RolesEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).join();
    });
    if (message.fixed_camouflage !== false) {
      writer.uint32(40).bool(message.fixed_camouflage);
    }
    writer.uint32(50).fork();
    for (const v of message.camouflages) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(58).fork();
    for (const v of message.ancestors) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(66).fork();
    for (const v of message.successors) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.crew) {
      Crew.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.health !== 0) {
      writer.uint32(80).uint32(message.health);
    }
    if (message.nation !== '') {
      writer.uint32(90).string(message.nation);
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(98).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(104).int32(message.type);
    }
    if (message.max_consumables !== 0) {
      writer.uint32(112).uint32(message.max_consumables);
    }
    if (message.max_provisions !== 0) {
      writer.uint32(120).uint32(message.max_provisions);
    }
    if (message.tier !== 0) {
      writer.uint32(128).uint32(message.tier);
    }
    if (message.class !== 0) {
      writer.uint32(136).int32(message.class);
    }
    if (message.testing !== false) {
      writer.uint32(144).bool(message.testing);
    }
    if (message.deprecated !== false) {
      writer.uint32(152).bool(message.deprecated);
    }
    for (const v of message.turrets) {
      TurretDefinition.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.engines) {
      EngineDefinition.encode(v!, writer.uint32(170).fork()).join();
    }
    for (const v of message.tracks) {
      TrackDefinition.encode(v!, writer.uint32(178).fork()).join();
    }
    if (message.price !== undefined) {
      TankPrice.encode(message.price, writer.uint32(186).fork()).join();
    }
    if (message.research_cost !== undefined) {
      ResearchCost.encode(
        message.research_cost,
        writer.uint32(194).fork(),
      ).join();
    }
    if (message.speed_forwards !== 0) {
      writer.uint32(205).float(message.speed_forwards);
    }
    if (message.speed_backwards !== 0) {
      writer.uint32(213).float(message.speed_backwards);
    }
    if (message.camouflage_still !== 0) {
      writer.uint32(221).float(message.camouflage_still);
    }
    if (message.camouflage_moving !== 0) {
      writer.uint32(229).float(message.camouflage_moving);
    }
    if (message.camouflage_onFire !== 0) {
      writer.uint32(237).float(message.camouflage_onFire);
    }
    if (message.equipment_preset !== '') {
      writer.uint32(242).string(message.equipment_preset);
    }
    if (message.weight !== 0) {
      writer.uint32(248).uint32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TankDefinition {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTankDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = TankDefinition_RolesEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry3.value !== undefined) {
            message.roles[entry3.key] = entry3.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fixed_camouflage = reader.bool();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.camouflages.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.camouflages.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            message.ancestors.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ancestors.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 64) {
            message.successors.push(reader.int32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.successors.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.crew.push(Crew.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.health = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.nation = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.max_consumables = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.max_provisions = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.class = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.testing = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.deprecated = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.turrets.push(
            TurretDefinition.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.engines.push(
            EngineDefinition.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.tracks.push(TrackDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.price = TankPrice.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.research_cost = ResearchCost.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 205) {
            break;
          }

          message.speed_forwards = reader.float();
          continue;
        }
        case 26: {
          if (tag !== 213) {
            break;
          }

          message.speed_backwards = reader.float();
          continue;
        }
        case 27: {
          if (tag !== 221) {
            break;
          }

          message.camouflage_still = reader.float();
          continue;
        }
        case 28: {
          if (tag !== 229) {
            break;
          }

          message.camouflage_moving = reader.float();
          continue;
        }
        case 29: {
          if (tag !== 237) {
            break;
          }

          message.camouflage_onFire = reader.float();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.equipment_preset = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TankDefinition {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      slug: isSet(object.slug) ? globalThis.String(object.slug) : '',
      roles: isObject(object.roles)
        ? Object.entries(object.roles).reduce<{ [key: number]: number }>(
            (acc, [key, value]) => {
              acc[globalThis.Number(key)] = Number(value);
              return acc;
            },
            {},
          )
        : {},
      fixed_camouflage: isSet(object.fixed_camouflage)
        ? globalThis.Boolean(object.fixed_camouflage)
        : false,
      camouflages: globalThis.Array.isArray(object?.camouflages)
        ? object.camouflages.map((e: any) => globalThis.Number(e))
        : [],
      ancestors: globalThis.Array.isArray(object?.ancestors)
        ? object.ancestors.map((e: any) => globalThis.Number(e))
        : [],
      successors: globalThis.Array.isArray(object?.successors)
        ? object.successors.map((e: any) => globalThis.Number(e))
        : [],
      crew: globalThis.Array.isArray(object?.crew)
        ? object.crew.map((e: any) => Crew.fromJSON(e))
        : [],
      health: isSet(object.health) ? globalThis.Number(object.health) : 0,
      nation: isSet(object.nation) ? globalThis.String(object.nation) : '',
      name: isSet(object.name) ? I18nString.fromJSON(object.name) : undefined,
      type: isSet(object.type) ? tankTypeFromJSON(object.type) : 0,
      max_consumables: isSet(object.max_consumables)
        ? globalThis.Number(object.max_consumables)
        : 0,
      max_provisions: isSet(object.max_provisions)
        ? globalThis.Number(object.max_provisions)
        : 0,
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      class: isSet(object.class) ? tankClassFromJSON(object.class) : 0,
      testing: isSet(object.testing)
        ? globalThis.Boolean(object.testing)
        : false,
      deprecated: isSet(object.deprecated)
        ? globalThis.Boolean(object.deprecated)
        : false,
      turrets: globalThis.Array.isArray(object?.turrets)
        ? object.turrets.map((e: any) => TurretDefinition.fromJSON(e))
        : [],
      engines: globalThis.Array.isArray(object?.engines)
        ? object.engines.map((e: any) => EngineDefinition.fromJSON(e))
        : [],
      tracks: globalThis.Array.isArray(object?.tracks)
        ? object.tracks.map((e: any) => TrackDefinition.fromJSON(e))
        : [],
      price: isSet(object.price) ? TankPrice.fromJSON(object.price) : undefined,
      research_cost: isSet(object.research_cost)
        ? ResearchCost.fromJSON(object.research_cost)
        : undefined,
      speed_forwards: isSet(object.speed_forwards)
        ? globalThis.Number(object.speed_forwards)
        : 0,
      speed_backwards: isSet(object.speed_backwards)
        ? globalThis.Number(object.speed_backwards)
        : 0,
      camouflage_still: isSet(object.camouflage_still)
        ? globalThis.Number(object.camouflage_still)
        : 0,
      camouflage_moving: isSet(object.camouflage_moving)
        ? globalThis.Number(object.camouflage_moving)
        : 0,
      camouflage_onFire: isSet(object.camouflage_onFire)
        ? globalThis.Number(object.camouflage_onFire)
        : 0,
      equipment_preset: isSet(object.equipment_preset)
        ? globalThis.String(object.equipment_preset)
        : '',
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: TankDefinition): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.slug !== '') {
      obj.slug = message.slug;
    }
    if (message.roles) {
      const entries = Object.entries(message.roles);
      if (entries.length > 0) {
        obj.roles = {};
        entries.forEach(([k, v]) => {
          obj.roles[k] = Math.round(v);
        });
      }
    }
    if (message.fixed_camouflage !== false) {
      obj.fixed_camouflage = message.fixed_camouflage;
    }
    if (message.camouflages?.length) {
      obj.camouflages = message.camouflages.map((e) => Math.round(e));
    }
    if (message.ancestors?.length) {
      obj.ancestors = message.ancestors.map((e) => Math.round(e));
    }
    if (message.successors?.length) {
      obj.successors = message.successors.map((e) => Math.round(e));
    }
    if (message.crew?.length) {
      obj.crew = message.crew.map((e) => Crew.toJSON(e));
    }
    if (message.health !== 0) {
      obj.health = Math.round(message.health);
    }
    if (message.nation !== '') {
      obj.nation = message.nation;
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.type !== 0) {
      obj.type = tankTypeToJSON(message.type);
    }
    if (message.max_consumables !== 0) {
      obj.max_consumables = Math.round(message.max_consumables);
    }
    if (message.max_provisions !== 0) {
      obj.max_provisions = Math.round(message.max_provisions);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.class !== 0) {
      obj.class = tankClassToJSON(message.class);
    }
    if (message.testing !== false) {
      obj.testing = message.testing;
    }
    if (message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.turrets?.length) {
      obj.turrets = message.turrets.map((e) => TurretDefinition.toJSON(e));
    }
    if (message.engines?.length) {
      obj.engines = message.engines.map((e) => EngineDefinition.toJSON(e));
    }
    if (message.tracks?.length) {
      obj.tracks = message.tracks.map((e) => TrackDefinition.toJSON(e));
    }
    if (message.price !== undefined) {
      obj.price = TankPrice.toJSON(message.price);
    }
    if (message.research_cost !== undefined) {
      obj.research_cost = ResearchCost.toJSON(message.research_cost);
    }
    if (message.speed_forwards !== 0) {
      obj.speed_forwards = message.speed_forwards;
    }
    if (message.speed_backwards !== 0) {
      obj.speed_backwards = message.speed_backwards;
    }
    if (message.camouflage_still !== 0) {
      obj.camouflage_still = message.camouflage_still;
    }
    if (message.camouflage_moving !== 0) {
      obj.camouflage_moving = message.camouflage_moving;
    }
    if (message.camouflage_onFire !== 0) {
      obj.camouflage_onFire = message.camouflage_onFire;
    }
    if (message.equipment_preset !== '') {
      obj.equipment_preset = message.equipment_preset;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TankDefinition>, I>>(
    base?: I,
  ): TankDefinition {
    return TankDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TankDefinition>, I>>(
    object: I,
  ): TankDefinition {
    const message = createBaseTankDefinition();
    message.id = object.id ?? 0;
    message.slug = object.slug ?? '';
    message.roles = Object.entries(object.roles ?? {}).reduce<{
      [key: number]: number;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.fixed_camouflage = object.fixed_camouflage ?? false;
    message.camouflages = object.camouflages?.map((e) => e) || [];
    message.ancestors = object.ancestors?.map((e) => e) || [];
    message.successors = object.successors?.map((e) => e) || [];
    message.crew = object.crew?.map((e) => Crew.fromPartial(e)) || [];
    message.health = object.health ?? 0;
    message.nation = object.nation ?? '';
    message.name =
      object.name !== undefined && object.name !== null
        ? I18nString.fromPartial(object.name)
        : undefined;
    message.type = object.type ?? 0;
    message.max_consumables = object.max_consumables ?? 0;
    message.max_provisions = object.max_provisions ?? 0;
    message.tier = object.tier ?? 0;
    message.class = object.class ?? 0;
    message.testing = object.testing ?? false;
    message.deprecated = object.deprecated ?? false;
    message.turrets =
      object.turrets?.map((e) => TurretDefinition.fromPartial(e)) || [];
    message.engines =
      object.engines?.map((e) => EngineDefinition.fromPartial(e)) || [];
    message.tracks =
      object.tracks?.map((e) => TrackDefinition.fromPartial(e)) || [];
    message.price =
      object.price !== undefined && object.price !== null
        ? TankPrice.fromPartial(object.price)
        : undefined;
    message.research_cost =
      object.research_cost !== undefined && object.research_cost !== null
        ? ResearchCost.fromPartial(object.research_cost)
        : undefined;
    message.speed_forwards = object.speed_forwards ?? 0;
    message.speed_backwards = object.speed_backwards ?? 0;
    message.camouflage_still = object.camouflage_still ?? 0;
    message.camouflage_moving = object.camouflage_moving ?? 0;
    message.camouflage_onFire = object.camouflage_onFire ?? 0;
    message.equipment_preset = object.equipment_preset ?? '';
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseTankDefinition_RolesEntry(): TankDefinition_RolesEntry {
  return { key: 0, value: 0 };
}

export const TankDefinition_RolesEntry: MessageFns<TankDefinition_RolesEntry> =
  {
    encode(
      message: TankDefinition_RolesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== 0) {
        writer.uint32(8).uint32(message.key);
      }
      if (message.value !== 0) {
        writer.uint32(16).uint32(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TankDefinition_RolesEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTankDefinition_RolesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.key = reader.uint32();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.value = reader.uint32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TankDefinition_RolesEntry {
      return {
        key: isSet(object.key) ? globalThis.Number(object.key) : 0,
        value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      };
    },

    toJSON(message: TankDefinition_RolesEntry): unknown {
      const obj: any = {};
      if (message.key !== 0) {
        obj.key = Math.round(message.key);
      }
      if (message.value !== 0) {
        obj.value = Math.round(message.value);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<TankDefinition_RolesEntry>, I>>(
      base?: I,
    ): TankDefinition_RolesEntry {
      return TankDefinition_RolesEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TankDefinition_RolesEntry>, I>>(
      object: I,
    ): TankDefinition_RolesEntry {
      const message = createBaseTankDefinition_RolesEntry();
      message.key = object.key ?? 0;
      message.value = object.value ?? 0;
      return message;
    },
  };

function createBaseResearchCost(): ResearchCost {
  return { research_cost_type: undefined };
}

export const ResearchCost: MessageFns<ResearchCost> = {
  encode(
    message: ResearchCost,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.research_cost_type?.$case) {
      case 'xp':
        writer.uint32(8).uint32(message.research_cost_type.value);
        break;
      case 'seasonal_tokens':
        ResearchCostSeasonalTokens.encode(
          message.research_cost_type.value,
          writer.uint32(18).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResearchCost {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResearchCost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.research_cost_type = { $case: 'xp', value: reader.uint32() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.research_cost_type = {
            $case: 'seasonal_tokens',
            value: ResearchCostSeasonalTokens.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResearchCost {
    return {
      research_cost_type: isSet(object.xp)
        ? { $case: 'xp', value: globalThis.Number(object.xp) }
        : isSet(object.seasonal_tokens)
          ? {
              $case: 'seasonal_tokens',
              value: ResearchCostSeasonalTokens.fromJSON(
                object.seasonal_tokens,
              ),
            }
          : undefined,
    };
  },

  toJSON(message: ResearchCost): unknown {
    const obj: any = {};
    if (message.research_cost_type?.$case === 'xp') {
      obj.xp = Math.round(message.research_cost_type.value);
    }
    if (message.research_cost_type?.$case === 'seasonal_tokens') {
      obj.seasonal_tokens = ResearchCostSeasonalTokens.toJSON(
        message.research_cost_type.value,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResearchCost>, I>>(
    base?: I,
  ): ResearchCost {
    return ResearchCost.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResearchCost>, I>>(
    object: I,
  ): ResearchCost {
    const message = createBaseResearchCost();
    if (
      object.research_cost_type?.$case === 'xp' &&
      object.research_cost_type?.value !== undefined &&
      object.research_cost_type?.value !== null
    ) {
      message.research_cost_type = {
        $case: 'xp',
        value: object.research_cost_type.value,
      };
    }
    if (
      object.research_cost_type?.$case === 'seasonal_tokens' &&
      object.research_cost_type?.value !== undefined &&
      object.research_cost_type?.value !== null
    ) {
      message.research_cost_type = {
        $case: 'seasonal_tokens',
        value: ResearchCostSeasonalTokens.fromPartial(
          object.research_cost_type.value,
        ),
      };
    }
    return message;
  },
};

function createBaseResearchCostSeasonalTokens(): ResearchCostSeasonalTokens {
  return { season: 0, tokens: 0 };
}

export const ResearchCostSeasonalTokens: MessageFns<ResearchCostSeasonalTokens> =
  {
    encode(
      message: ResearchCostSeasonalTokens,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.season !== 0) {
        writer.uint32(8).uint32(message.season);
      }
      if (message.tokens !== 0) {
        writer.uint32(16).uint32(message.tokens);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ResearchCostSeasonalTokens {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseResearchCostSeasonalTokens();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.season = reader.uint32();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.tokens = reader.uint32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ResearchCostSeasonalTokens {
      return {
        season: isSet(object.season) ? globalThis.Number(object.season) : 0,
        tokens: isSet(object.tokens) ? globalThis.Number(object.tokens) : 0,
      };
    },

    toJSON(message: ResearchCostSeasonalTokens): unknown {
      const obj: any = {};
      if (message.season !== 0) {
        obj.season = Math.round(message.season);
      }
      if (message.tokens !== 0) {
        obj.tokens = Math.round(message.tokens);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ResearchCostSeasonalTokens>, I>>(
      base?: I,
    ): ResearchCostSeasonalTokens {
      return ResearchCostSeasonalTokens.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ResearchCostSeasonalTokens>, I>>(
      object: I,
    ): ResearchCostSeasonalTokens {
      const message = createBaseResearchCostSeasonalTokens();
      message.season = object.season ?? 0;
      message.tokens = object.tokens ?? 0;
      return message;
    },
  };

function createBaseTankPrice(): TankPrice {
  return { type: 0, value: 0 };
}

export const TankPrice: MessageFns<TankPrice> = {
  encode(
    message: TankPrice,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TankPrice {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTankPrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TankPrice {
    return {
      type: isSet(object.type) ? tankPriceTypeFromJSON(object.type) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: TankPrice): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = tankPriceTypeToJSON(message.type);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TankPrice>, I>>(base?: I): TankPrice {
    return TankPrice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TankPrice>, I>>(
    object: I,
  ): TankPrice {
    const message = createBaseTankPrice();
    message.type = object.type ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseTrackDefinition(): TrackDefinition {
  return {
    id: 0,
    tier: 0,
    name: undefined,
    weight: 0,
    traverse_speed: 0,
    research_cost: undefined,
    dispersion_move: 0,
    dispersion_traverse: 0,
    resistance_hard: 0,
    resistance_medium: 0,
    resistance_soft: 0,
    unlocks: [],
  };
}

export const TrackDefinition: MessageFns<TrackDefinition> = {
  encode(
    message: TrackDefinition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.tier !== 0) {
      writer.uint32(16).uint32(message.tier);
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(26).fork()).join();
    }
    if (message.weight !== 0) {
      writer.uint32(32).uint32(message.weight);
    }
    if (message.traverse_speed !== 0) {
      writer.uint32(45).float(message.traverse_speed);
    }
    if (message.research_cost !== undefined) {
      ResearchCost.encode(
        message.research_cost,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.dispersion_move !== 0) {
      writer.uint32(61).float(message.dispersion_move);
    }
    if (message.dispersion_traverse !== 0) {
      writer.uint32(69).float(message.dispersion_traverse);
    }
    if (message.resistance_hard !== 0) {
      writer.uint32(77).float(message.resistance_hard);
    }
    if (message.resistance_medium !== 0) {
      writer.uint32(85).float(message.resistance_medium);
    }
    if (message.resistance_soft !== 0) {
      writer.uint32(93).float(message.resistance_soft);
    }
    for (const v of message.unlocks) {
      Unlock.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackDefinition {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.traverse_speed = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.research_cost = ResearchCost.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.dispersion_move = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.dispersion_traverse = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.resistance_hard = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.resistance_medium = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.resistance_soft = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.unlocks.push(Unlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackDefinition {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      name: isSet(object.name) ? I18nString.fromJSON(object.name) : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      traverse_speed: isSet(object.traverse_speed)
        ? globalThis.Number(object.traverse_speed)
        : 0,
      research_cost: isSet(object.research_cost)
        ? ResearchCost.fromJSON(object.research_cost)
        : undefined,
      dispersion_move: isSet(object.dispersion_move)
        ? globalThis.Number(object.dispersion_move)
        : 0,
      dispersion_traverse: isSet(object.dispersion_traverse)
        ? globalThis.Number(object.dispersion_traverse)
        : 0,
      resistance_hard: isSet(object.resistance_hard)
        ? globalThis.Number(object.resistance_hard)
        : 0,
      resistance_medium: isSet(object.resistance_medium)
        ? globalThis.Number(object.resistance_medium)
        : 0,
      resistance_soft: isSet(object.resistance_soft)
        ? globalThis.Number(object.resistance_soft)
        : 0,
      unlocks: globalThis.Array.isArray(object?.unlocks)
        ? object.unlocks.map((e: any) => Unlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TrackDefinition): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.traverse_speed !== 0) {
      obj.traverse_speed = message.traverse_speed;
    }
    if (message.research_cost !== undefined) {
      obj.research_cost = ResearchCost.toJSON(message.research_cost);
    }
    if (message.dispersion_move !== 0) {
      obj.dispersion_move = message.dispersion_move;
    }
    if (message.dispersion_traverse !== 0) {
      obj.dispersion_traverse = message.dispersion_traverse;
    }
    if (message.resistance_hard !== 0) {
      obj.resistance_hard = message.resistance_hard;
    }
    if (message.resistance_medium !== 0) {
      obj.resistance_medium = message.resistance_medium;
    }
    if (message.resistance_soft !== 0) {
      obj.resistance_soft = message.resistance_soft;
    }
    if (message.unlocks?.length) {
      obj.unlocks = message.unlocks.map((e) => Unlock.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackDefinition>, I>>(
    base?: I,
  ): TrackDefinition {
    return TrackDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackDefinition>, I>>(
    object: I,
  ): TrackDefinition {
    const message = createBaseTrackDefinition();
    message.id = object.id ?? 0;
    message.tier = object.tier ?? 0;
    message.name =
      object.name !== undefined && object.name !== null
        ? I18nString.fromPartial(object.name)
        : undefined;
    message.weight = object.weight ?? 0;
    message.traverse_speed = object.traverse_speed ?? 0;
    message.research_cost =
      object.research_cost !== undefined && object.research_cost !== null
        ? ResearchCost.fromPartial(object.research_cost)
        : undefined;
    message.dispersion_move = object.dispersion_move ?? 0;
    message.dispersion_traverse = object.dispersion_traverse ?? 0;
    message.resistance_hard = object.resistance_hard ?? 0;
    message.resistance_medium = object.resistance_medium ?? 0;
    message.resistance_soft = object.resistance_soft ?? 0;
    message.unlocks = object.unlocks?.map((e) => Unlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEngineDefinition(): EngineDefinition {
  return {
    id: 0,
    name: undefined,
    research_cost: undefined,
    tier: 0,
    fire_chance: 0,
    power: 0,
    weight: 0,
    unlocks: [],
  };
}

export const EngineDefinition: MessageFns<EngineDefinition> = {
  encode(
    message: EngineDefinition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(18).fork()).join();
    }
    if (message.research_cost !== undefined) {
      ResearchCost.encode(
        message.research_cost,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.tier !== 0) {
      writer.uint32(32).uint32(message.tier);
    }
    if (message.fire_chance !== 0) {
      writer.uint32(45).float(message.fire_chance);
    }
    if (message.power !== 0) {
      writer.uint32(48).uint32(message.power);
    }
    if (message.weight !== 0) {
      writer.uint32(56).uint32(message.weight);
    }
    for (const v of message.unlocks) {
      Unlock.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineDefinition {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.research_cost = ResearchCost.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.fire_chance = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.power = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.unlocks.push(Unlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineDefinition {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? I18nString.fromJSON(object.name) : undefined,
      research_cost: isSet(object.research_cost)
        ? ResearchCost.fromJSON(object.research_cost)
        : undefined,
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      fire_chance: isSet(object.fire_chance)
        ? globalThis.Number(object.fire_chance)
        : 0,
      power: isSet(object.power) ? globalThis.Number(object.power) : 0,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      unlocks: globalThis.Array.isArray(object?.unlocks)
        ? object.unlocks.map((e: any) => Unlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EngineDefinition): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.research_cost !== undefined) {
      obj.research_cost = ResearchCost.toJSON(message.research_cost);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.fire_chance !== 0) {
      obj.fire_chance = message.fire_chance;
    }
    if (message.power !== 0) {
      obj.power = Math.round(message.power);
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.unlocks?.length) {
      obj.unlocks = message.unlocks.map((e) => Unlock.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EngineDefinition>, I>>(
    base?: I,
  ): EngineDefinition {
    return EngineDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EngineDefinition>, I>>(
    object: I,
  ): EngineDefinition {
    const message = createBaseEngineDefinition();
    message.id = object.id ?? 0;
    message.name =
      object.name !== undefined && object.name !== null
        ? I18nString.fromPartial(object.name)
        : undefined;
    message.research_cost =
      object.research_cost !== undefined && object.research_cost !== null
        ? ResearchCost.fromPartial(object.research_cost)
        : undefined;
    message.tier = object.tier ?? 0;
    message.fire_chance = object.fire_chance ?? 0;
    message.power = object.power ?? 0;
    message.weight = object.weight ?? 0;
    message.unlocks = object.unlocks?.map((e) => Unlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTurretDefinition(): TurretDefinition {
  return {
    id: 0,
    health: 0,
    view_range: 0,
    traverse_speed: 0,
    research_cost: undefined,
    name: undefined,
    tier: 0,
    weight: 0,
    guns: [],
    unlocks: [],
  };
}

export const TurretDefinition: MessageFns<TurretDefinition> = {
  encode(
    message: TurretDefinition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.health !== 0) {
      writer.uint32(16).uint32(message.health);
    }
    if (message.view_range !== 0) {
      writer.uint32(24).uint32(message.view_range);
    }
    if (message.traverse_speed !== 0) {
      writer.uint32(37).float(message.traverse_speed);
    }
    if (message.research_cost !== undefined) {
      ResearchCost.encode(
        message.research_cost,
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(50).fork()).join();
    }
    if (message.tier !== 0) {
      writer.uint32(56).uint32(message.tier);
    }
    if (message.weight !== 0) {
      writer.uint32(64).uint32(message.weight);
    }
    for (const v of message.guns) {
      GunDefinition.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.unlocks) {
      Unlock.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurretDefinition {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurretDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.health = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.view_range = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.traverse_speed = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.research_cost = ResearchCost.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.guns.push(GunDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.unlocks.push(Unlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurretDefinition {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      health: isSet(object.health) ? globalThis.Number(object.health) : 0,
      view_range: isSet(object.view_range)
        ? globalThis.Number(object.view_range)
        : 0,
      traverse_speed: isSet(object.traverse_speed)
        ? globalThis.Number(object.traverse_speed)
        : 0,
      research_cost: isSet(object.research_cost)
        ? ResearchCost.fromJSON(object.research_cost)
        : undefined,
      name: isSet(object.name) ? I18nString.fromJSON(object.name) : undefined,
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      guns: globalThis.Array.isArray(object?.guns)
        ? object.guns.map((e: any) => GunDefinition.fromJSON(e))
        : [],
      unlocks: globalThis.Array.isArray(object?.unlocks)
        ? object.unlocks.map((e: any) => Unlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TurretDefinition): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.health !== 0) {
      obj.health = Math.round(message.health);
    }
    if (message.view_range !== 0) {
      obj.view_range = Math.round(message.view_range);
    }
    if (message.traverse_speed !== 0) {
      obj.traverse_speed = message.traverse_speed;
    }
    if (message.research_cost !== undefined) {
      obj.research_cost = ResearchCost.toJSON(message.research_cost);
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.guns?.length) {
      obj.guns = message.guns.map((e) => GunDefinition.toJSON(e));
    }
    if (message.unlocks?.length) {
      obj.unlocks = message.unlocks.map((e) => Unlock.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurretDefinition>, I>>(
    base?: I,
  ): TurretDefinition {
    return TurretDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurretDefinition>, I>>(
    object: I,
  ): TurretDefinition {
    const message = createBaseTurretDefinition();
    message.id = object.id ?? 0;
    message.health = object.health ?? 0;
    message.view_range = object.view_range ?? 0;
    message.traverse_speed = object.traverse_speed ?? 0;
    message.research_cost =
      object.research_cost !== undefined && object.research_cost !== null
        ? ResearchCost.fromPartial(object.research_cost)
        : undefined;
    message.name =
      object.name !== undefined && object.name !== null
        ? I18nString.fromPartial(object.name)
        : undefined;
    message.tier = object.tier ?? 0;
    message.weight = object.weight ?? 0;
    message.guns = object.guns?.map((e) => GunDefinition.fromPartial(e)) || [];
    message.unlocks = object.unlocks?.map((e) => Unlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGunDefinition(): GunDefinition {
  return { gun_type: undefined };
}

export const GunDefinition: MessageFns<GunDefinition> = {
  encode(
    message: GunDefinition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.gun_type?.$case) {
      case 'regular':
        GunDefinitionRegular.encode(
          message.gun_type.value,
          writer.uint32(10).fork(),
        ).join();
        break;
      case 'auto_loader':
        GunDefinitionAutoLoader.encode(
          message.gun_type.value,
          writer.uint32(18).fork(),
        ).join();
        break;
      case 'auto_reloader':
        GunDefinitionAutoReloader.encode(
          message.gun_type.value,
          writer.uint32(26).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GunDefinition {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gun_type = {
            $case: 'regular',
            value: GunDefinitionRegular.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gun_type = {
            $case: 'auto_loader',
            value: GunDefinitionAutoLoader.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gun_type = {
            $case: 'auto_reloader',
            value: GunDefinitionAutoReloader.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinition {
    return {
      gun_type: isSet(object.regular)
        ? {
            $case: 'regular',
            value: GunDefinitionRegular.fromJSON(object.regular),
          }
        : isSet(object.auto_loader)
          ? {
              $case: 'auto_loader',
              value: GunDefinitionAutoLoader.fromJSON(object.auto_loader),
            }
          : isSet(object.auto_reloader)
            ? {
                $case: 'auto_reloader',
                value: GunDefinitionAutoReloader.fromJSON(object.auto_reloader),
              }
            : undefined,
    };
  },

  toJSON(message: GunDefinition): unknown {
    const obj: any = {};
    if (message.gun_type?.$case === 'regular') {
      obj.regular = GunDefinitionRegular.toJSON(message.gun_type.value);
    }
    if (message.gun_type?.$case === 'auto_loader') {
      obj.auto_loader = GunDefinitionAutoLoader.toJSON(message.gun_type.value);
    }
    if (message.gun_type?.$case === 'auto_reloader') {
      obj.auto_reloader = GunDefinitionAutoReloader.toJSON(
        message.gun_type.value,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinition>, I>>(
    base?: I,
  ): GunDefinition {
    return GunDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinition>, I>>(
    object: I,
  ): GunDefinition {
    const message = createBaseGunDefinition();
    if (
      object.gun_type?.$case === 'regular' &&
      object.gun_type?.value !== undefined &&
      object.gun_type?.value !== null
    ) {
      message.gun_type = {
        $case: 'regular',
        value: GunDefinitionRegular.fromPartial(object.gun_type.value),
      };
    }
    if (
      object.gun_type?.$case === 'auto_loader' &&
      object.gun_type?.value !== undefined &&
      object.gun_type?.value !== null
    ) {
      message.gun_type = {
        $case: 'auto_loader',
        value: GunDefinitionAutoLoader.fromPartial(object.gun_type.value),
      };
    }
    if (
      object.gun_type?.$case === 'auto_reloader' &&
      object.gun_type?.value !== undefined &&
      object.gun_type?.value !== null
    ) {
      message.gun_type = {
        $case: 'auto_reloader',
        value: GunDefinitionAutoReloader.fromPartial(object.gun_type.value),
      };
    }
    return message;
  },
};

function createBaseGunDefinitionRegular(): GunDefinitionRegular {
  return { base: undefined, extension: undefined };
}

export const GunDefinitionRegular: MessageFns<GunDefinitionRegular> = {
  encode(
    message: GunDefinitionRegular,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.base !== undefined) {
      GunDefinitionBase.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.extension !== undefined) {
      GunDefinitionRegularProperties.encode(
        message.extension,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GunDefinitionRegular {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinitionRegular();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = GunDefinitionBase.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.extension = GunDefinitionRegularProperties.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinitionRegular {
    return {
      base: isSet(object.base)
        ? GunDefinitionBase.fromJSON(object.base)
        : undefined,
      extension: isSet(object.extension)
        ? GunDefinitionRegularProperties.fromJSON(object.extension)
        : undefined,
    };
  },

  toJSON(message: GunDefinitionRegular): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = GunDefinitionBase.toJSON(message.base);
    }
    if (message.extension !== undefined) {
      obj.extension = GunDefinitionRegularProperties.toJSON(message.extension);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinitionRegular>, I>>(
    base?: I,
  ): GunDefinitionRegular {
    return GunDefinitionRegular.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinitionRegular>, I>>(
    object: I,
  ): GunDefinitionRegular {
    const message = createBaseGunDefinitionRegular();
    message.base =
      object.base !== undefined && object.base !== null
        ? GunDefinitionBase.fromPartial(object.base)
        : undefined;
    message.extension =
      object.extension !== undefined && object.extension !== null
        ? GunDefinitionRegularProperties.fromPartial(object.extension)
        : undefined;
    return message;
  },
};

function createBaseGunDefinitionRegularProperties(): GunDefinitionRegularProperties {
  return { reload: 0 };
}

export const GunDefinitionRegularProperties: MessageFns<GunDefinitionRegularProperties> =
  {
    encode(
      message: GunDefinitionRegularProperties,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.reload !== 0) {
        writer.uint32(13).float(message.reload);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GunDefinitionRegularProperties {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGunDefinitionRegularProperties();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 13) {
              break;
            }

            message.reload = reader.float();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GunDefinitionRegularProperties {
      return {
        reload: isSet(object.reload) ? globalThis.Number(object.reload) : 0,
      };
    },

    toJSON(message: GunDefinitionRegularProperties): unknown {
      const obj: any = {};
      if (message.reload !== 0) {
        obj.reload = message.reload;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GunDefinitionRegularProperties>, I>>(
      base?: I,
    ): GunDefinitionRegularProperties {
      return GunDefinitionRegularProperties.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<GunDefinitionRegularProperties>, I>,
    >(object: I): GunDefinitionRegularProperties {
      const message = createBaseGunDefinitionRegularProperties();
      message.reload = object.reload ?? 0;
      return message;
    },
  };

function createBaseGunDefinitionAutoLoader(): GunDefinitionAutoLoader {
  return { base: undefined, extension: undefined };
}

export const GunDefinitionAutoLoader: MessageFns<GunDefinitionAutoLoader> = {
  encode(
    message: GunDefinitionAutoLoader,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.base !== undefined) {
      GunDefinitionBase.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.extension !== undefined) {
      GunDefinitionAutoLoaderProperties.encode(
        message.extension,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GunDefinitionAutoLoader {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinitionAutoLoader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = GunDefinitionBase.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.extension = GunDefinitionAutoLoaderProperties.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinitionAutoLoader {
    return {
      base: isSet(object.base)
        ? GunDefinitionBase.fromJSON(object.base)
        : undefined,
      extension: isSet(object.extension)
        ? GunDefinitionAutoLoaderProperties.fromJSON(object.extension)
        : undefined,
    };
  },

  toJSON(message: GunDefinitionAutoLoader): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = GunDefinitionBase.toJSON(message.base);
    }
    if (message.extension !== undefined) {
      obj.extension = GunDefinitionAutoLoaderProperties.toJSON(
        message.extension,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinitionAutoLoader>, I>>(
    base?: I,
  ): GunDefinitionAutoLoader {
    return GunDefinitionAutoLoader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinitionAutoLoader>, I>>(
    object: I,
  ): GunDefinitionAutoLoader {
    const message = createBaseGunDefinitionAutoLoader();
    message.base =
      object.base !== undefined && object.base !== null
        ? GunDefinitionBase.fromPartial(object.base)
        : undefined;
    message.extension =
      object.extension !== undefined && object.extension !== null
        ? GunDefinitionAutoLoaderProperties.fromPartial(object.extension)
        : undefined;
    return message;
  },
};

function createBaseGunDefinitionAutoLoaderProperties(): GunDefinitionAutoLoaderProperties {
  return { clip_reload: 0, intra_clip: 0, shell_count: 0 };
}

export const GunDefinitionAutoLoaderProperties: MessageFns<GunDefinitionAutoLoaderProperties> =
  {
    encode(
      message: GunDefinitionAutoLoaderProperties,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.clip_reload !== 0) {
        writer.uint32(13).float(message.clip_reload);
      }
      if (message.intra_clip !== 0) {
        writer.uint32(21).float(message.intra_clip);
      }
      if (message.shell_count !== 0) {
        writer.uint32(29).float(message.shell_count);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GunDefinitionAutoLoaderProperties {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGunDefinitionAutoLoaderProperties();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 13) {
              break;
            }

            message.clip_reload = reader.float();
            continue;
          }
          case 2: {
            if (tag !== 21) {
              break;
            }

            message.intra_clip = reader.float();
            continue;
          }
          case 3: {
            if (tag !== 29) {
              break;
            }

            message.shell_count = reader.float();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GunDefinitionAutoLoaderProperties {
      return {
        clip_reload: isSet(object.clip_reload)
          ? globalThis.Number(object.clip_reload)
          : 0,
        intra_clip: isSet(object.intra_clip)
          ? globalThis.Number(object.intra_clip)
          : 0,
        shell_count: isSet(object.shell_count)
          ? globalThis.Number(object.shell_count)
          : 0,
      };
    },

    toJSON(message: GunDefinitionAutoLoaderProperties): unknown {
      const obj: any = {};
      if (message.clip_reload !== 0) {
        obj.clip_reload = message.clip_reload;
      }
      if (message.intra_clip !== 0) {
        obj.intra_clip = message.intra_clip;
      }
      if (message.shell_count !== 0) {
        obj.shell_count = message.shell_count;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GunDefinitionAutoLoaderProperties>, I>>(
      base?: I,
    ): GunDefinitionAutoLoaderProperties {
      return GunDefinitionAutoLoaderProperties.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<GunDefinitionAutoLoaderProperties>, I>,
    >(object: I): GunDefinitionAutoLoaderProperties {
      const message = createBaseGunDefinitionAutoLoaderProperties();
      message.clip_reload = object.clip_reload ?? 0;
      message.intra_clip = object.intra_clip ?? 0;
      message.shell_count = object.shell_count ?? 0;
      return message;
    },
  };

function createBaseGunDefinitionAutoReloader(): GunDefinitionAutoReloader {
  return { base: undefined, extension: undefined };
}

export const GunDefinitionAutoReloader: MessageFns<GunDefinitionAutoReloader> =
  {
    encode(
      message: GunDefinitionAutoReloader,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.base !== undefined) {
        GunDefinitionBase.encode(message.base, writer.uint32(10).fork()).join();
      }
      if (message.extension !== undefined) {
        GunDefinitionAutoReloaderProperties.encode(
          message.extension,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GunDefinitionAutoReloader {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGunDefinitionAutoReloader();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.base = GunDefinitionBase.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.extension = GunDefinitionAutoReloaderProperties.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GunDefinitionAutoReloader {
      return {
        base: isSet(object.base)
          ? GunDefinitionBase.fromJSON(object.base)
          : undefined,
        extension: isSet(object.extension)
          ? GunDefinitionAutoReloaderProperties.fromJSON(object.extension)
          : undefined,
      };
    },

    toJSON(message: GunDefinitionAutoReloader): unknown {
      const obj: any = {};
      if (message.base !== undefined) {
        obj.base = GunDefinitionBase.toJSON(message.base);
      }
      if (message.extension !== undefined) {
        obj.extension = GunDefinitionAutoReloaderProperties.toJSON(
          message.extension,
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GunDefinitionAutoReloader>, I>>(
      base?: I,
    ): GunDefinitionAutoReloader {
      return GunDefinitionAutoReloader.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GunDefinitionAutoReloader>, I>>(
      object: I,
    ): GunDefinitionAutoReloader {
      const message = createBaseGunDefinitionAutoReloader();
      message.base =
        object.base !== undefined && object.base !== null
          ? GunDefinitionBase.fromPartial(object.base)
          : undefined;
      message.extension =
        object.extension !== undefined && object.extension !== null
          ? GunDefinitionAutoReloaderProperties.fromPartial(object.extension)
          : undefined;
      return message;
    },
  };

function createBaseGunDefinitionAutoReloaderProperties(): GunDefinitionAutoReloaderProperties {
  return { shell_reloads: [], intra_clip: 0, shell_count: 0 };
}

export const GunDefinitionAutoReloaderProperties: MessageFns<GunDefinitionAutoReloaderProperties> =
  {
    encode(
      message: GunDefinitionAutoReloaderProperties,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      writer.uint32(10).fork();
      for (const v of message.shell_reloads) {
        writer.float(v);
      }
      writer.join();
      if (message.intra_clip !== 0) {
        writer.uint32(21).float(message.intra_clip);
      }
      if (message.shell_count !== 0) {
        writer.uint32(29).float(message.shell_count);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GunDefinitionAutoReloaderProperties {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGunDefinitionAutoReloaderProperties();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag === 13) {
              message.shell_reloads.push(reader.float());

              continue;
            }

            if (tag === 10) {
              const end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) {
                message.shell_reloads.push(reader.float());
              }

              continue;
            }

            break;
          }
          case 2: {
            if (tag !== 21) {
              break;
            }

            message.intra_clip = reader.float();
            continue;
          }
          case 3: {
            if (tag !== 29) {
              break;
            }

            message.shell_count = reader.float();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GunDefinitionAutoReloaderProperties {
      return {
        shell_reloads: globalThis.Array.isArray(object?.shell_reloads)
          ? object.shell_reloads.map((e: any) => globalThis.Number(e))
          : [],
        intra_clip: isSet(object.intra_clip)
          ? globalThis.Number(object.intra_clip)
          : 0,
        shell_count: isSet(object.shell_count)
          ? globalThis.Number(object.shell_count)
          : 0,
      };
    },

    toJSON(message: GunDefinitionAutoReloaderProperties): unknown {
      const obj: any = {};
      if (message.shell_reloads?.length) {
        obj.shell_reloads = message.shell_reloads;
      }
      if (message.intra_clip !== 0) {
        obj.intra_clip = message.intra_clip;
      }
      if (message.shell_count !== 0) {
        obj.shell_count = message.shell_count;
      }
      return obj;
    },

    create<
      I extends Exact<DeepPartial<GunDefinitionAutoReloaderProperties>, I>,
    >(base?: I): GunDefinitionAutoReloaderProperties {
      return GunDefinitionAutoReloaderProperties.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<GunDefinitionAutoReloaderProperties>, I>,
    >(object: I): GunDefinitionAutoReloaderProperties {
      const message = createBaseGunDefinitionAutoReloaderProperties();
      message.shell_reloads = object.shell_reloads?.map((e) => e) || [];
      message.intra_clip = object.intra_clip ?? 0;
      message.shell_count = object.shell_count ?? 0;
      return message;
    },
  };

function createBaseGunDefinitionBase(): GunDefinitionBase {
  return {
    id: 0,
    rotation_speed: 0,
    research_cost: undefined,
    weight: 0,
    name: undefined,
    tier: 0,
    shells: [],
    camouflage_loss: 0,
    aim_time: 0,
    dispersion_base: 0,
    dispersion_traverse: 0,
    dispersion_shot: 0,
    dispersion_damaged: 0,
    unlocks: [],
    shell_capacity: 0,
    assault_ranges: undefined,
  };
}

export const GunDefinitionBase: MessageFns<GunDefinitionBase> = {
  encode(
    message: GunDefinitionBase,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.rotation_speed !== 0) {
      writer.uint32(21).float(message.rotation_speed);
    }
    if (message.research_cost !== undefined) {
      ResearchCost.encode(
        message.research_cost,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.weight !== 0) {
      writer.uint32(32).uint32(message.weight);
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(42).fork()).join();
    }
    if (message.tier !== 0) {
      writer.uint32(48).uint32(message.tier);
    }
    for (const v of message.shells) {
      ShellDefinition.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.camouflage_loss !== 0) {
      writer.uint32(69).float(message.camouflage_loss);
    }
    if (message.aim_time !== 0) {
      writer.uint32(77).float(message.aim_time);
    }
    if (message.dispersion_base !== 0) {
      writer.uint32(85).float(message.dispersion_base);
    }
    if (message.dispersion_traverse !== 0) {
      writer.uint32(93).float(message.dispersion_traverse);
    }
    if (message.dispersion_shot !== 0) {
      writer.uint32(101).float(message.dispersion_shot);
    }
    if (message.dispersion_damaged !== 0) {
      writer.uint32(109).float(message.dispersion_damaged);
    }
    for (const v of message.unlocks) {
      Unlock.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.shell_capacity !== 0) {
      writer.uint32(120).uint32(message.shell_capacity);
    }
    if (message.assault_ranges !== undefined) {
      AssaultRanges.encode(
        message.assault_ranges,
        writer.uint32(130).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GunDefinitionBase {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinitionBase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.rotation_speed = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.research_cost = ResearchCost.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.shells.push(ShellDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.camouflage_loss = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.aim_time = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.dispersion_base = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.dispersion_traverse = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.dispersion_shot = reader.float();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.dispersion_damaged = reader.float();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.unlocks.push(Unlock.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.shell_capacity = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.assault_ranges = AssaultRanges.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinitionBase {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      rotation_speed: isSet(object.rotation_speed)
        ? globalThis.Number(object.rotation_speed)
        : 0,
      research_cost: isSet(object.research_cost)
        ? ResearchCost.fromJSON(object.research_cost)
        : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      name: isSet(object.name) ? I18nString.fromJSON(object.name) : undefined,
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      shells: globalThis.Array.isArray(object?.shells)
        ? object.shells.map((e: any) => ShellDefinition.fromJSON(e))
        : [],
      camouflage_loss: isSet(object.camouflage_loss)
        ? globalThis.Number(object.camouflage_loss)
        : 0,
      aim_time: isSet(object.aim_time) ? globalThis.Number(object.aim_time) : 0,
      dispersion_base: isSet(object.dispersion_base)
        ? globalThis.Number(object.dispersion_base)
        : 0,
      dispersion_traverse: isSet(object.dispersion_traverse)
        ? globalThis.Number(object.dispersion_traverse)
        : 0,
      dispersion_shot: isSet(object.dispersion_shot)
        ? globalThis.Number(object.dispersion_shot)
        : 0,
      dispersion_damaged: isSet(object.dispersion_damaged)
        ? globalThis.Number(object.dispersion_damaged)
        : 0,
      unlocks: globalThis.Array.isArray(object?.unlocks)
        ? object.unlocks.map((e: any) => Unlock.fromJSON(e))
        : [],
      shell_capacity: isSet(object.shell_capacity)
        ? globalThis.Number(object.shell_capacity)
        : 0,
      assault_ranges: isSet(object.assault_ranges)
        ? AssaultRanges.fromJSON(object.assault_ranges)
        : undefined,
    };
  },

  toJSON(message: GunDefinitionBase): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.rotation_speed !== 0) {
      obj.rotation_speed = message.rotation_speed;
    }
    if (message.research_cost !== undefined) {
      obj.research_cost = ResearchCost.toJSON(message.research_cost);
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.shells?.length) {
      obj.shells = message.shells.map((e) => ShellDefinition.toJSON(e));
    }
    if (message.camouflage_loss !== 0) {
      obj.camouflage_loss = message.camouflage_loss;
    }
    if (message.aim_time !== 0) {
      obj.aim_time = message.aim_time;
    }
    if (message.dispersion_base !== 0) {
      obj.dispersion_base = message.dispersion_base;
    }
    if (message.dispersion_traverse !== 0) {
      obj.dispersion_traverse = message.dispersion_traverse;
    }
    if (message.dispersion_shot !== 0) {
      obj.dispersion_shot = message.dispersion_shot;
    }
    if (message.dispersion_damaged !== 0) {
      obj.dispersion_damaged = message.dispersion_damaged;
    }
    if (message.unlocks?.length) {
      obj.unlocks = message.unlocks.map((e) => Unlock.toJSON(e));
    }
    if (message.shell_capacity !== 0) {
      obj.shell_capacity = Math.round(message.shell_capacity);
    }
    if (message.assault_ranges !== undefined) {
      obj.assault_ranges = AssaultRanges.toJSON(message.assault_ranges);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinitionBase>, I>>(
    base?: I,
  ): GunDefinitionBase {
    return GunDefinitionBase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinitionBase>, I>>(
    object: I,
  ): GunDefinitionBase {
    const message = createBaseGunDefinitionBase();
    message.id = object.id ?? 0;
    message.rotation_speed = object.rotation_speed ?? 0;
    message.research_cost =
      object.research_cost !== undefined && object.research_cost !== null
        ? ResearchCost.fromPartial(object.research_cost)
        : undefined;
    message.weight = object.weight ?? 0;
    message.name =
      object.name !== undefined && object.name !== null
        ? I18nString.fromPartial(object.name)
        : undefined;
    message.tier = object.tier ?? 0;
    message.shells =
      object.shells?.map((e) => ShellDefinition.fromPartial(e)) || [];
    message.camouflage_loss = object.camouflage_loss ?? 0;
    message.aim_time = object.aim_time ?? 0;
    message.dispersion_base = object.dispersion_base ?? 0;
    message.dispersion_traverse = object.dispersion_traverse ?? 0;
    message.dispersion_shot = object.dispersion_shot ?? 0;
    message.dispersion_damaged = object.dispersion_damaged ?? 0;
    message.unlocks = object.unlocks?.map((e) => Unlock.fromPartial(e)) || [];
    message.shell_capacity = object.shell_capacity ?? 0;
    message.assault_ranges =
      object.assault_ranges !== undefined && object.assault_ranges !== null
        ? AssaultRanges.fromPartial(object.assault_ranges)
        : undefined;
    return message;
  },
};

function createBaseAssaultRanges(): AssaultRanges {
  return { ranges: [], types: [] };
}

export const AssaultRanges: MessageFns<AssaultRanges> = {
  encode(
    message: AssaultRanges,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.ranges) {
      AssaultRange.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.types) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssaultRanges {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssaultRanges();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ranges.push(AssaultRange.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.types.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.types.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssaultRanges {
    return {
      ranges: globalThis.Array.isArray(object?.ranges)
        ? object.ranges.map((e: any) => AssaultRange.fromJSON(e))
        : [],
      types: globalThis.Array.isArray(object?.types)
        ? object.types.map((e: any) => shellTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: AssaultRanges): unknown {
    const obj: any = {};
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => AssaultRange.toJSON(e));
    }
    if (message.types?.length) {
      obj.types = message.types.map((e) => shellTypeToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssaultRanges>, I>>(
    base?: I,
  ): AssaultRanges {
    return AssaultRanges.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssaultRanges>, I>>(
    object: I,
  ): AssaultRanges {
    const message = createBaseAssaultRanges();
    message.ranges =
      object.ranges?.map((e) => AssaultRange.fromPartial(e)) || [];
    message.types = object.types?.map((e) => e) || [];
    return message;
  },
};

function createBaseAssaultRange(): AssaultRange {
  return { distance: 0, factor: 0 };
}

export const AssaultRange: MessageFns<AssaultRange> = {
  encode(
    message: AssaultRange,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.distance !== 0) {
      writer.uint32(13).float(message.distance);
    }
    if (message.factor !== 0) {
      writer.uint32(21).float(message.factor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssaultRange {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssaultRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.distance = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.factor = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssaultRange {
    return {
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
      factor: isSet(object.factor) ? globalThis.Number(object.factor) : 0,
    };
  },

  toJSON(message: AssaultRange): unknown {
    const obj: any = {};
    if (message.distance !== 0) {
      obj.distance = message.distance;
    }
    if (message.factor !== 0) {
      obj.factor = message.factor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssaultRange>, I>>(
    base?: I,
  ): AssaultRange {
    return AssaultRange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssaultRange>, I>>(
    object: I,
  ): AssaultRange {
    const message = createBaseAssaultRange();
    message.distance = object.distance ?? 0;
    message.factor = object.factor ?? 0;
    return message;
  },
};

function createBaseShellDefinition(): ShellDefinition {
  return {
    id: 0,
    name: undefined,
    velocity: 0,
    armor_damage: 0,
    module_damage: 0,
    caliber: 0,
    icon: '',
    penetration: undefined,
    type: 0,
    normalization: 0,
    ricochet: 0,
    explosion_radius: 0,
    range: 0,
  };
}

export const ShellDefinition: MessageFns<ShellDefinition> = {
  encode(
    message: ShellDefinition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(18).fork()).join();
    }
    if (message.velocity !== 0) {
      writer.uint32(24).uint32(message.velocity);
    }
    if (message.armor_damage !== 0) {
      writer.uint32(32).uint32(message.armor_damage);
    }
    if (message.module_damage !== 0) {
      writer.uint32(40).uint32(message.module_damage);
    }
    if (message.caliber !== 0) {
      writer.uint32(53).float(message.caliber);
    }
    if (message.icon !== '') {
      writer.uint32(58).string(message.icon);
    }
    if (message.penetration !== undefined) {
      ShellPenetration.encode(
        message.penetration,
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.normalization !== undefined && message.normalization !== 0) {
      writer.uint32(85).float(message.normalization);
    }
    if (message.ricochet !== undefined && message.ricochet !== 0) {
      writer.uint32(93).float(message.ricochet);
    }
    if (
      message.explosion_radius !== undefined &&
      message.explosion_radius !== 0
    ) {
      writer.uint32(101).float(message.explosion_radius);
    }
    if (message.range !== 0) {
      writer.uint32(104).uint32(message.range);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellDefinition {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.velocity = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.armor_damage = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.module_damage = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.caliber = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.icon = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.penetration = ShellPenetration.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.normalization = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.ricochet = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.explosion_radius = reader.float();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.range = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellDefinition {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? I18nString.fromJSON(object.name) : undefined,
      velocity: isSet(object.velocity) ? globalThis.Number(object.velocity) : 0,
      armor_damage: isSet(object.armor_damage)
        ? globalThis.Number(object.armor_damage)
        : 0,
      module_damage: isSet(object.module_damage)
        ? globalThis.Number(object.module_damage)
        : 0,
      caliber: isSet(object.caliber) ? globalThis.Number(object.caliber) : 0,
      icon: isSet(object.icon) ? globalThis.String(object.icon) : '',
      penetration: isSet(object.penetration)
        ? ShellPenetration.fromJSON(object.penetration)
        : undefined,
      type: isSet(object.type) ? shellTypeFromJSON(object.type) : 0,
      normalization: isSet(object.normalization)
        ? globalThis.Number(object.normalization)
        : 0,
      ricochet: isSet(object.ricochet) ? globalThis.Number(object.ricochet) : 0,
      explosion_radius: isSet(object.explosion_radius)
        ? globalThis.Number(object.explosion_radius)
        : 0,
      range: isSet(object.range) ? globalThis.Number(object.range) : 0,
    };
  },

  toJSON(message: ShellDefinition): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.velocity !== 0) {
      obj.velocity = Math.round(message.velocity);
    }
    if (message.armor_damage !== 0) {
      obj.armor_damage = Math.round(message.armor_damage);
    }
    if (message.module_damage !== 0) {
      obj.module_damage = Math.round(message.module_damage);
    }
    if (message.caliber !== 0) {
      obj.caliber = message.caliber;
    }
    if (message.icon !== '') {
      obj.icon = message.icon;
    }
    if (message.penetration !== undefined) {
      obj.penetration = ShellPenetration.toJSON(message.penetration);
    }
    if (message.type !== 0) {
      obj.type = shellTypeToJSON(message.type);
    }
    if (message.normalization !== undefined && message.normalization !== 0) {
      obj.normalization = message.normalization;
    }
    if (message.ricochet !== undefined && message.ricochet !== 0) {
      obj.ricochet = message.ricochet;
    }
    if (
      message.explosion_radius !== undefined &&
      message.explosion_radius !== 0
    ) {
      obj.explosion_radius = message.explosion_radius;
    }
    if (message.range !== 0) {
      obj.range = Math.round(message.range);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellDefinition>, I>>(
    base?: I,
  ): ShellDefinition {
    return ShellDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellDefinition>, I>>(
    object: I,
  ): ShellDefinition {
    const message = createBaseShellDefinition();
    message.id = object.id ?? 0;
    message.name =
      object.name !== undefined && object.name !== null
        ? I18nString.fromPartial(object.name)
        : undefined;
    message.velocity = object.velocity ?? 0;
    message.armor_damage = object.armor_damage ?? 0;
    message.module_damage = object.module_damage ?? 0;
    message.caliber = object.caliber ?? 0;
    message.icon = object.icon ?? '';
    message.penetration =
      object.penetration !== undefined && object.penetration !== null
        ? ShellPenetration.fromPartial(object.penetration)
        : undefined;
    message.type = object.type ?? 0;
    message.normalization = object.normalization ?? 0;
    message.ricochet = object.ricochet ?? 0;
    message.explosion_radius = object.explosion_radius ?? 0;
    message.range = object.range ?? 0;
    return message;
  },
};

function createBaseShellPenetration(): ShellPenetration {
  return { near: 0, far: 0 };
}

export const ShellPenetration: MessageFns<ShellPenetration> = {
  encode(
    message: ShellPenetration,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.near !== 0) {
      writer.uint32(13).float(message.near);
    }
    if (message.far !== 0) {
      writer.uint32(21).float(message.far);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellPenetration {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellPenetration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.near = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.far = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellPenetration {
    return {
      near: isSet(object.near) ? globalThis.Number(object.near) : 0,
      far: isSet(object.far) ? globalThis.Number(object.far) : 0,
    };
  },

  toJSON(message: ShellPenetration): unknown {
    const obj: any = {};
    if (message.near !== 0) {
      obj.near = message.near;
    }
    if (message.far !== 0) {
      obj.far = message.far;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellPenetration>, I>>(
    base?: I,
  ): ShellPenetration {
    return ShellPenetration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellPenetration>, I>>(
    object: I,
  ): ShellPenetration {
    const message = createBaseShellPenetration();
    message.near = object.near ?? 0;
    message.far = object.far ?? 0;
    return message;
  },
};

function createBaseUnlock(): Unlock {
  return { id: 0, type: 0, cost: undefined };
}

export const Unlock: MessageFns<Unlock> = {
  encode(
    message: Unlock,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.cost !== undefined) {
      UnlockCost.encode(message.cost, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Unlock {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cost = UnlockCost.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Unlock {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      type: isSet(object.type) ? moduleTypeFromJSON(object.type) : 0,
      cost: isSet(object.cost) ? UnlockCost.fromJSON(object.cost) : undefined,
    };
  },

  toJSON(message: Unlock): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== 0) {
      obj.type = moduleTypeToJSON(message.type);
    }
    if (message.cost !== undefined) {
      obj.cost = UnlockCost.toJSON(message.cost);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Unlock>, I>>(base?: I): Unlock {
    return Unlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Unlock>, I>>(object: I): Unlock {
    const message = createBaseUnlock();
    message.id = object.id ?? 0;
    message.type = object.type ?? 0;
    message.cost =
      object.cost !== undefined && object.cost !== null
        ? UnlockCost.fromPartial(object.cost)
        : undefined;
    return message;
  },
};

function createBaseUnlockCost(): UnlockCost {
  return { type: '', value: 0 };
}

export const UnlockCost: MessageFns<UnlockCost> = {
  encode(
    message: UnlockCost,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== '') {
      writer.uint32(10).string(message.type);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnlockCost {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockCost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnlockCost {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: UnlockCost): unknown {
    const obj: any = {};
    if (message.type !== '') {
      obj.type = message.type;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnlockCost>, I>>(base?: I): UnlockCost {
    return UnlockCost.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnlockCost>, I>>(
    object: I,
  ): UnlockCost {
    const message = createBaseUnlockCost();
    message.type = object.type ?? '';
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCrew(): Crew {
  return { type: 0, count: 0, substitute: [] };
}

export const Crew: MessageFns<Crew> = {
  encode(
    message: Crew,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    writer.uint32(26).fork();
    for (const v of message.substitute) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Crew {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrew();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.substitute.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.substitute.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Crew {
    return {
      type: isSet(object.type) ? crewTypeFromJSON(object.type) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      substitute: globalThis.Array.isArray(object?.substitute)
        ? object.substitute.map((e: any) => crewTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: Crew): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = crewTypeToJSON(message.type);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.substitute?.length) {
      obj.substitute = message.substitute.map((e) => crewTypeToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Crew>, I>>(base?: I): Crew {
    return Crew.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Crew>, I>>(object: I): Crew {
    const message = createBaseCrew();
    message.type = object.type ?? 0;
    message.count = object.count ?? 0;
    message.substitute = object.substitute?.map((e) => e) || [];
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends { $case: string; value: unknown }
        ? { $case: T['$case']; value?: DeepPartial<T['value']> }
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isObject(value: any): boolean {
  return typeof value === 'object' && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
