// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.2
//   protoc               v5.28.2
// source: tank_definitions.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { createBaseI18nString, I18nString } from "./i18n";

export const protobufPackage = "blitzkit";

export enum TankPriceType {
  TANK_PRICE_TYPE_CREDITS = 0,
  TANK_PRICE_TYPE_GOLD = 1,
}

export function tankPriceTypeFromJSON(object: any): TankPriceType {
  switch (object) {
    case 0:
    case "TANK_PRICE_TYPE_CREDITS":
      return TankPriceType.TANK_PRICE_TYPE_CREDITS;
    case 1:
    case "TANK_PRICE_TYPE_GOLD":
      return TankPriceType.TANK_PRICE_TYPE_GOLD;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TankPriceType");
  }
}

export function tankPriceTypeToJSON(object: TankPriceType): string {
  switch (object) {
    case TankPriceType.TANK_PRICE_TYPE_CREDITS:
      return "TANK_PRICE_TYPE_CREDITS";
    case TankPriceType.TANK_PRICE_TYPE_GOLD:
      return "TANK_PRICE_TYPE_GOLD";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TankPriceType");
  }
}

export enum ShellType {
  SHELL_TYPE_AP = 0,
  SHELL_TYPE_APCR = 1,
  SHELL_TYPE_HEAT = 2,
  SHELL_TYPE_HE = 3,
}

export function shellTypeFromJSON(object: any): ShellType {
  switch (object) {
    case 0:
    case "SHELL_TYPE_AP":
      return ShellType.SHELL_TYPE_AP;
    case 1:
    case "SHELL_TYPE_APCR":
      return ShellType.SHELL_TYPE_APCR;
    case 2:
    case "SHELL_TYPE_HEAT":
      return ShellType.SHELL_TYPE_HEAT;
    case 3:
    case "SHELL_TYPE_HE":
      return ShellType.SHELL_TYPE_HE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ShellType");
  }
}

export function shellTypeToJSON(object: ShellType): string {
  switch (object) {
    case ShellType.SHELL_TYPE_AP:
      return "SHELL_TYPE_AP";
    case ShellType.SHELL_TYPE_APCR:
      return "SHELL_TYPE_APCR";
    case ShellType.SHELL_TYPE_HEAT:
      return "SHELL_TYPE_HEAT";
    case ShellType.SHELL_TYPE_HE:
      return "SHELL_TYPE_HE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ShellType");
  }
}

export enum ModuleType {
  MODULE_TYPE_VEHICLE = 0,
  MODULE_TYPE_ENGINE = 1,
  MODULE_TYPE_TRACKS = 2,
  MODULE_TYPE_TURRET = 3,
  MODULE_TYPE_GUN = 4,
}

export function moduleTypeFromJSON(object: any): ModuleType {
  switch (object) {
    case 0:
    case "MODULE_TYPE_VEHICLE":
      return ModuleType.MODULE_TYPE_VEHICLE;
    case 1:
    case "MODULE_TYPE_ENGINE":
      return ModuleType.MODULE_TYPE_ENGINE;
    case 2:
    case "MODULE_TYPE_TRACKS":
      return ModuleType.MODULE_TYPE_TRACKS;
    case 3:
    case "MODULE_TYPE_TURRET":
      return ModuleType.MODULE_TYPE_TURRET;
    case 4:
    case "MODULE_TYPE_GUN":
      return ModuleType.MODULE_TYPE_GUN;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ModuleType");
  }
}

export function moduleTypeToJSON(object: ModuleType): string {
  switch (object) {
    case ModuleType.MODULE_TYPE_VEHICLE:
      return "MODULE_TYPE_VEHICLE";
    case ModuleType.MODULE_TYPE_ENGINE:
      return "MODULE_TYPE_ENGINE";
    case ModuleType.MODULE_TYPE_TRACKS:
      return "MODULE_TYPE_TRACKS";
    case ModuleType.MODULE_TYPE_TURRET:
      return "MODULE_TYPE_TURRET";
    case ModuleType.MODULE_TYPE_GUN:
      return "MODULE_TYPE_GUN";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ModuleType");
  }
}

export enum TankClass {
  TANK_CLASS_LIGHT = 0,
  TANK_CLASS_MEDIUM = 1,
  TANK_CLASS_HEAVY = 2,
  TANK_CLASS_TANK_DESTROYER = 3,
}

export function tankClassFromJSON(object: any): TankClass {
  switch (object) {
    case 0:
    case "TANK_CLASS_LIGHT":
      return TankClass.TANK_CLASS_LIGHT;
    case 1:
    case "TANK_CLASS_MEDIUM":
      return TankClass.TANK_CLASS_MEDIUM;
    case 2:
    case "TANK_CLASS_HEAVY":
      return TankClass.TANK_CLASS_HEAVY;
    case 3:
    case "TANK_CLASS_TANK_DESTROYER":
      return TankClass.TANK_CLASS_TANK_DESTROYER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TankClass");
  }
}

export function tankClassToJSON(object: TankClass): string {
  switch (object) {
    case TankClass.TANK_CLASS_LIGHT:
      return "TANK_CLASS_LIGHT";
    case TankClass.TANK_CLASS_MEDIUM:
      return "TANK_CLASS_MEDIUM";
    case TankClass.TANK_CLASS_HEAVY:
      return "TANK_CLASS_HEAVY";
    case TankClass.TANK_CLASS_TANK_DESTROYER:
      return "TANK_CLASS_TANK_DESTROYER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TankClass");
  }
}

export enum TankType {
  TANK_TYPE_RESEARCHABLE = 0,
  TANK_TYPE_PREMIUM = 1,
  TANK_TYPE_COLLECTOR = 2,
}

export function tankTypeFromJSON(object: any): TankType {
  switch (object) {
    case 0:
    case "TANK_TYPE_RESEARCHABLE":
      return TankType.TANK_TYPE_RESEARCHABLE;
    case 1:
    case "TANK_TYPE_PREMIUM":
      return TankType.TANK_TYPE_PREMIUM;
    case 2:
    case "TANK_TYPE_COLLECTOR":
      return TankType.TANK_TYPE_COLLECTOR;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TankType");
  }
}

export function tankTypeToJSON(object: TankType): string {
  switch (object) {
    case TankType.TANK_TYPE_RESEARCHABLE:
      return "TANK_TYPE_RESEARCHABLE";
    case TankType.TANK_TYPE_PREMIUM:
      return "TANK_TYPE_PREMIUM";
    case TankType.TANK_TYPE_COLLECTOR:
      return "TANK_TYPE_COLLECTOR";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TankType");
  }
}

export enum CrewType {
  CREW_TYPE_COMMANDER = 0,
  CREW_TYPE_RADIOMAN = 1,
  CREW_TYPE_GUNNER = 2,
  CREW_TYPE_DRIVER = 3,
  CREW_TYPE_LOADER = 4,
}

export function crewTypeFromJSON(object: any): CrewType {
  switch (object) {
    case 0:
    case "CREW_TYPE_COMMANDER":
      return CrewType.CREW_TYPE_COMMANDER;
    case 1:
    case "CREW_TYPE_RADIOMAN":
      return CrewType.CREW_TYPE_RADIOMAN;
    case 2:
    case "CREW_TYPE_GUNNER":
      return CrewType.CREW_TYPE_GUNNER;
    case 3:
    case "CREW_TYPE_DRIVER":
      return CrewType.CREW_TYPE_DRIVER;
    case 4:
    case "CREW_TYPE_LOADER":
      return CrewType.CREW_TYPE_LOADER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CrewType");
  }
}

export function crewTypeToJSON(object: CrewType): string {
  switch (object) {
    case CrewType.CREW_TYPE_COMMANDER:
      return "CREW_TYPE_COMMANDER";
    case CrewType.CREW_TYPE_RADIOMAN:
      return "CREW_TYPE_RADIOMAN";
    case CrewType.CREW_TYPE_GUNNER:
      return "CREW_TYPE_GUNNER";
    case CrewType.CREW_TYPE_DRIVER:
      return "CREW_TYPE_DRIVER";
    case CrewType.CREW_TYPE_LOADER:
      return "CREW_TYPE_LOADER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CrewType");
  }
}

export interface TankDefinitions {
  tanks: { [key: number]: TankDefinition };
}

export interface TankDefinitions_TanksEntry {
  key: number;
  value: TankDefinition | undefined;
}

export interface TankDefinition {
  id: number;
  slug: string;
  roles: { [key: number]: number };
  fixed_camouflage: boolean;
  camouflages: number[];
  ancestors: number[];
  successors: number[];
  crew: Crew[];
  health: number;
  nation: string;
  name: I18nString;
  type: TankType;
  max_consumables: number;
  max_provisions: number;
  tier: number;
  class: TankClass;
  testing: boolean;
  deprecated: boolean;
  turrets: TurretDefinition[];
  engines: EngineDefinition[];
  tracks: TrackDefinition[];
  price: TankPrice;
  research_cost?: ResearchCost | undefined;
  speed_forwards: number;
  speed_backwards: number;
  camouflage_still: number;
  camouflage_moving: number;
  camouflage_onFire: number;
  equipment_preset: string;
  weight: number;
}

export interface TankDefinition_RolesEntry {
  key: number;
  value: number;
}

export interface ResearchCost {
  research_cost_type?:
    | { $case: "xp"; value: number }
    | { $case: "seasonal_tokens"; value: ResearchCostSeasonalTokens }
    | undefined;
}

export interface ResearchCostSeasonalTokens {
  season: number;
  tokens: number;
}

export interface TankPrice {
  type: TankPriceType;
  value: number;
}

export interface TrackDefinition {
  id: number;
  tier: number;
  name: I18nString;
  weight: number;
  traverse_speed: number;
  research_cost?: ResearchCost | undefined;
  dispersion_move: number;
  dispersion_traverse: number;
  resistance_hard: number;
  resistance_medium: number;
  resistance_soft: number;
  unlocks: Unlock[];
}

export interface EngineDefinition {
  id: number;
  name: I18nString;
  research_cost?: ResearchCost | undefined;
  tier: number;
  fire_chance: number;
  power: number;
  weight: number;
  unlocks: Unlock[];
}

export interface TurretDefinition {
  id: number;
  health: number;
  view_range: number;
  traverse_speed: number;
  research_cost?: ResearchCost | undefined;
  name: I18nString;
  tier: number;
  weight: number;
  guns: GunDefinition[];
  unlocks: Unlock[];
}

export interface GunDefinition {
  gun_type?:
    | { $case: "regular"; value: GunDefinitionRegular }
    | { $case: "auto_loader"; value: GunDefinitionAutoLoader }
    | { $case: "auto_reloader"; value: GunDefinitionAutoReloader }
    | undefined;
}

export interface GunDefinitionRegular {
  base: GunDefinitionBase;
  extension: GunDefinitionRegularProperties;
}

export interface GunDefinitionRegularProperties {
  reload: number;
}

export interface GunDefinitionAutoLoader {
  base: GunDefinitionBase;
  extension: GunDefinitionAutoLoaderProperties;
}

export interface GunDefinitionAutoLoaderProperties {
  clip_reload: number;
  intra_clip: number;
  shell_count: number;
}

export interface GunDefinitionAutoReloader {
  base: GunDefinitionBase;
  extension: GunDefinitionAutoReloaderProperties;
}

export interface GunDefinitionAutoReloaderProperties {
  shell_reloads: number[];
  intra_clip: number;
  shell_count: number;
}

export interface GunDefinitionBase {
  id: number;
  rotation_speed: number;
  research_cost?: ResearchCost | undefined;
  weight: number;
  name: I18nString;
  tier: number;
  shells: ShellDefinition[];
  camouflage_loss: number;
  aim_time: number;
  dispersion_base: number;
  dispersion_traverse: number;
  dispersion_shot: number;
  dispersion_damaged: number;
  unlocks: Unlock[];
  shell_capacity: number;
}

export interface ShellDefinition {
  id: number;
  name: I18nString;
  velocity: number;
  armor_damage: number;
  module_damage: number;
  caliber: number;
  icon: string;
  penetration: ShellPenetration;
  type: ShellType;
  normalization?: number | undefined;
  ricochet?: number | undefined;
  explosion_radius?: number | undefined;
  range: number;
}

export interface ShellPenetration {
  near: number;
  far: number;
}

export interface Unlock {
  id: number;
  type: ModuleType;
  cost: UnlockCost;
}

export interface UnlockCost {
  type: string;
  value: number;
}

export interface Crew {
  type: CrewType;
  count: number;
  substitute: CrewType[];
}

export function createBaseTankDefinitions(): TankDefinitions {
  return { tanks: {} };
}

export const TankDefinitions: MessageFns<TankDefinitions> = {
  encode(message: TankDefinitions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.tanks).forEach(([key, value]) => {
      TankDefinitions_TanksEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TankDefinitions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTankDefinitions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = TankDefinitions_TanksEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.tanks[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TankDefinitions {
    return {
      tanks: isObject(object.tanks)
        ? Object.entries(object.tanks).reduce<{ [key: number]: TankDefinition }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = TankDefinition.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TankDefinitions): unknown {
    const obj: any = {};
    if (message.tanks) {
      const entries = Object.entries(message.tanks);
      if (entries.length > 0) {
        obj.tanks = {};
        entries.forEach(([k, v]) => {
          obj.tanks[k] = TankDefinition.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TankDefinitions>, I>>(base?: I): TankDefinitions {
    return TankDefinitions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TankDefinitions>, I>>(object: I): TankDefinitions {
    const message = createBaseTankDefinitions();
    message.tanks = Object.entries(object.tanks ?? {}).reduce<{ [key: number]: TankDefinition }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = TankDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

export function createBaseTankDefinitions_TanksEntry(): TankDefinitions_TanksEntry {
  return { key: 0, value: createBaseTankDefinition() };
}

export const TankDefinitions_TanksEntry: MessageFns<TankDefinitions_TanksEntry> = {
  encode(message: TankDefinitions_TanksEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      TankDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TankDefinitions_TanksEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTankDefinitions_TanksEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = TankDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TankDefinitions_TanksEntry {
    return {
      key: globalThis.Number(assertSet("TankDefinitions_TanksEntry.key", object.key)),
      value: TankDefinition.fromJSON(assertSet("TankDefinitions_TanksEntry.value", object.value)),
    };
  },

  toJSON(message: TankDefinitions_TanksEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = TankDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TankDefinitions_TanksEntry>, I>>(base?: I): TankDefinitions_TanksEntry {
    return TankDefinitions_TanksEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TankDefinitions_TanksEntry>, I>>(object: I): TankDefinitions_TanksEntry {
    const message = createBaseTankDefinitions_TanksEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? TankDefinition.fromPartial(object.value)
      : createBaseTankDefinition();
    return message;
  },
};

export function createBaseTankDefinition(): TankDefinition {
  return {
    id: 0,
    slug: "",
    roles: {},
    fixed_camouflage: false,
    camouflages: [],
    ancestors: [],
    successors: [],
    crew: [],
    health: 0,
    nation: "",
    name: createBaseI18nString(),
    type: 0,
    max_consumables: 0,
    max_provisions: 0,
    tier: 0,
    class: 0,
    testing: false,
    deprecated: false,
    turrets: [],
    engines: [],
    tracks: [],
    price: createBaseTankPrice(),
    research_cost: undefined,
    speed_forwards: 0,
    speed_backwards: 0,
    camouflage_still: 0,
    camouflage_moving: 0,
    camouflage_onFire: 0,
    equipment_preset: "",
    weight: 0,
  };
}

export const TankDefinition: MessageFns<TankDefinition> = {
  encode(message: TankDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.slug !== "") {
      writer.uint32(18).string(message.slug);
    }
    Object.entries(message.roles).forEach(([key, value]) => {
      TankDefinition_RolesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.fixed_camouflage !== false) {
      writer.uint32(40).bool(message.fixed_camouflage);
    }
    writer.uint32(50).fork();
    for (const v of message.camouflages) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(58).fork();
    for (const v of message.ancestors) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(66).fork();
    for (const v of message.successors) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.crew) {
      Crew.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.health !== 0) {
      writer.uint32(80).uint32(message.health);
    }
    if (message.nation !== "") {
      writer.uint32(90).string(message.nation);
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(98).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(104).int32(message.type);
    }
    if (message.max_consumables !== 0) {
      writer.uint32(112).uint32(message.max_consumables);
    }
    if (message.max_provisions !== 0) {
      writer.uint32(120).uint32(message.max_provisions);
    }
    if (message.tier !== 0) {
      writer.uint32(128).uint32(message.tier);
    }
    if (message.class !== 0) {
      writer.uint32(136).int32(message.class);
    }
    if (message.testing !== false) {
      writer.uint32(144).bool(message.testing);
    }
    if (message.deprecated !== false) {
      writer.uint32(152).bool(message.deprecated);
    }
    for (const v of message.turrets) {
      TurretDefinition.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.engines) {
      EngineDefinition.encode(v!, writer.uint32(170).fork()).join();
    }
    for (const v of message.tracks) {
      TrackDefinition.encode(v!, writer.uint32(178).fork()).join();
    }
    if (message.price !== undefined) {
      TankPrice.encode(message.price, writer.uint32(186).fork()).join();
    }
    if (message.research_cost !== undefined) {
      ResearchCost.encode(message.research_cost, writer.uint32(194).fork()).join();
    }
    if (message.speed_forwards !== 0) {
      writer.uint32(205).float(message.speed_forwards);
    }
    if (message.speed_backwards !== 0) {
      writer.uint32(213).float(message.speed_backwards);
    }
    if (message.camouflage_still !== 0) {
      writer.uint32(221).float(message.camouflage_still);
    }
    if (message.camouflage_moving !== 0) {
      writer.uint32(229).float(message.camouflage_moving);
    }
    if (message.camouflage_onFire !== 0) {
      writer.uint32(237).float(message.camouflage_onFire);
    }
    if (message.equipment_preset !== "") {
      writer.uint32(242).string(message.equipment_preset);
    }
    if (message.weight !== 0) {
      writer.uint32(248).uint32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TankDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTankDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = TankDefinition_RolesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.roles[entry3.key] = entry3.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fixed_camouflage = reader.bool();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.camouflages.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.camouflages.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            message.ancestors.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ancestors.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 64) {
            message.successors.push(reader.int32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.successors.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.crew.push(Crew.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.health = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.nation = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.max_consumables = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.max_provisions = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.class = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.testing = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.deprecated = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.turrets.push(TurretDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.engines.push(EngineDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.tracks.push(TrackDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.price = TankPrice.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.research_cost = ResearchCost.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 205) {
            break;
          }

          message.speed_forwards = reader.float();
          continue;
        }
        case 26: {
          if (tag !== 213) {
            break;
          }

          message.speed_backwards = reader.float();
          continue;
        }
        case 27: {
          if (tag !== 221) {
            break;
          }

          message.camouflage_still = reader.float();
          continue;
        }
        case 28: {
          if (tag !== 229) {
            break;
          }

          message.camouflage_moving = reader.float();
          continue;
        }
        case 29: {
          if (tag !== 237) {
            break;
          }

          message.camouflage_onFire = reader.float();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.equipment_preset = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TankDefinition {
    return {
      id: globalThis.Number(assertSet("TankDefinition.id", object.id)),
      slug: globalThis.String(assertSet("TankDefinition.slug", object.slug)),
      roles: isObject(object.roles)
        ? Object.entries(object.roles).reduce<{ [key: number]: number }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Number(value);
          return acc;
        }, {})
        : {},
      fixed_camouflage: globalThis.Boolean(assertSet("TankDefinition.fixed_camouflage", object.fixed_camouflage)),
      camouflages: globalThis.Array.isArray(object?.camouflages)
        ? object.camouflages.map((e: any) => globalThis.Number(e))
        : [],
      ancestors: globalThis.Array.isArray(object?.ancestors)
        ? object.ancestors.map((e: any) => globalThis.Number(e))
        : [],
      successors: globalThis.Array.isArray(object?.successors)
        ? object.successors.map((e: any) => globalThis.Number(e))
        : [],
      crew: globalThis.Array.isArray(object?.crew)
        ? object.crew.map((e: any) => Crew.fromJSON(e))
        : [],
      health: globalThis.Number(assertSet("TankDefinition.health", object.health)),
      nation: globalThis.String(assertSet("TankDefinition.nation", object.nation)),
      name: I18nString.fromJSON(assertSet("TankDefinition.name", object.name)),
      type: tankTypeFromJSON(assertSet("TankDefinition.type", object.type)),
      max_consumables: globalThis.Number(assertSet("TankDefinition.max_consumables", object.max_consumables)),
      max_provisions: globalThis.Number(assertSet("TankDefinition.max_provisions", object.max_provisions)),
      tier: globalThis.Number(assertSet("TankDefinition.tier", object.tier)),
      class: tankClassFromJSON(assertSet("TankDefinition.class", object.class)),
      testing: globalThis.Boolean(assertSet("TankDefinition.testing", object.testing)),
      deprecated: globalThis.Boolean(assertSet("TankDefinition.deprecated", object.deprecated)),
      turrets: globalThis.Array.isArray(object?.turrets)
        ? object.turrets.map((e: any) => TurretDefinition.fromJSON(e))
        : [],
      engines: globalThis.Array.isArray(object?.engines)
        ? object.engines.map((e: any) => EngineDefinition.fromJSON(e))
        : [],
      tracks: globalThis.Array.isArray(object?.tracks)
        ? object.tracks.map((e: any) => TrackDefinition.fromJSON(e))
        : [],
      price: TankPrice.fromJSON(assertSet("TankDefinition.price", object.price)),
      research_cost: isSet(object.research_cost) ? ResearchCost.fromJSON(object.research_cost) : undefined,
      speed_forwards: globalThis.Number(assertSet("TankDefinition.speed_forwards", object.speed_forwards)),
      speed_backwards: globalThis.Number(assertSet("TankDefinition.speed_backwards", object.speed_backwards)),
      camouflage_still: globalThis.Number(assertSet("TankDefinition.camouflage_still", object.camouflage_still)),
      camouflage_moving: globalThis.Number(assertSet("TankDefinition.camouflage_moving", object.camouflage_moving)),
      camouflage_onFire: globalThis.Number(assertSet("TankDefinition.camouflage_onFire", object.camouflage_onFire)),
      equipment_preset: globalThis.String(assertSet("TankDefinition.equipment_preset", object.equipment_preset)),
      weight: globalThis.Number(assertSet("TankDefinition.weight", object.weight)),
    };
  },

  toJSON(message: TankDefinition): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.roles) {
      const entries = Object.entries(message.roles);
      if (entries.length > 0) {
        obj.roles = {};
        entries.forEach(([k, v]) => {
          obj.roles[k] = Math.round(v);
        });
      }
    }
    if (message.fixed_camouflage !== false) {
      obj.fixed_camouflage = message.fixed_camouflage;
    }
    if (message.camouflages?.length) {
      obj.camouflages = message.camouflages.map((e) => Math.round(e));
    }
    if (message.ancestors?.length) {
      obj.ancestors = message.ancestors.map((e) => Math.round(e));
    }
    if (message.successors?.length) {
      obj.successors = message.successors.map((e) => Math.round(e));
    }
    if (message.crew?.length) {
      obj.crew = message.crew.map((e) => Crew.toJSON(e));
    }
    if (message.health !== 0) {
      obj.health = Math.round(message.health);
    }
    if (message.nation !== "") {
      obj.nation = message.nation;
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.type !== 0) {
      obj.type = tankTypeToJSON(message.type);
    }
    if (message.max_consumables !== 0) {
      obj.max_consumables = Math.round(message.max_consumables);
    }
    if (message.max_provisions !== 0) {
      obj.max_provisions = Math.round(message.max_provisions);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.class !== 0) {
      obj.class = tankClassToJSON(message.class);
    }
    if (message.testing !== false) {
      obj.testing = message.testing;
    }
    if (message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.turrets?.length) {
      obj.turrets = message.turrets.map((e) => TurretDefinition.toJSON(e));
    }
    if (message.engines?.length) {
      obj.engines = message.engines.map((e) => EngineDefinition.toJSON(e));
    }
    if (message.tracks?.length) {
      obj.tracks = message.tracks.map((e) => TrackDefinition.toJSON(e));
    }
    if (message.price !== undefined) {
      obj.price = TankPrice.toJSON(message.price);
    }
    if (message.research_cost !== undefined) {
      obj.research_cost = ResearchCost.toJSON(message.research_cost);
    }
    if (message.speed_forwards !== 0) {
      obj.speed_forwards = message.speed_forwards;
    }
    if (message.speed_backwards !== 0) {
      obj.speed_backwards = message.speed_backwards;
    }
    if (message.camouflage_still !== 0) {
      obj.camouflage_still = message.camouflage_still;
    }
    if (message.camouflage_moving !== 0) {
      obj.camouflage_moving = message.camouflage_moving;
    }
    if (message.camouflage_onFire !== 0) {
      obj.camouflage_onFire = message.camouflage_onFire;
    }
    if (message.equipment_preset !== "") {
      obj.equipment_preset = message.equipment_preset;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TankDefinition>, I>>(base?: I): TankDefinition {
    return TankDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TankDefinition>, I>>(object: I): TankDefinition {
    const message = createBaseTankDefinition();
    message.id = object.id ?? 0;
    message.slug = object.slug ?? "";
    message.roles = Object.entries(object.roles ?? {}).reduce<{ [key: number]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.fixed_camouflage = object.fixed_camouflage ?? false;
    message.camouflages = object.camouflages?.map((e) => e) || [];
    message.ancestors = object.ancestors?.map((e) => e) || [];
    message.successors = object.successors?.map((e) => e) || [];
    message.crew = object.crew?.map((e) => Crew.fromPartial(e)) || [];
    message.health = object.health ?? 0;
    message.nation = object.nation ?? "";
    message.name = (object.name !== undefined && object.name !== null)
      ? I18nString.fromPartial(object.name)
      : createBaseI18nString();
    message.type = object.type ?? 0;
    message.max_consumables = object.max_consumables ?? 0;
    message.max_provisions = object.max_provisions ?? 0;
    message.tier = object.tier ?? 0;
    message.class = object.class ?? 0;
    message.testing = object.testing ?? false;
    message.deprecated = object.deprecated ?? false;
    message.turrets = object.turrets?.map((e) => TurretDefinition.fromPartial(e)) || [];
    message.engines = object.engines?.map((e) => EngineDefinition.fromPartial(e)) || [];
    message.tracks = object.tracks?.map((e) => TrackDefinition.fromPartial(e)) || [];
    message.price = (object.price !== undefined && object.price !== null)
      ? TankPrice.fromPartial(object.price)
      : createBaseTankPrice();
    message.research_cost = (object.research_cost !== undefined && object.research_cost !== null)
      ? ResearchCost.fromPartial(object.research_cost)
      : undefined;
    message.speed_forwards = object.speed_forwards ?? 0;
    message.speed_backwards = object.speed_backwards ?? 0;
    message.camouflage_still = object.camouflage_still ?? 0;
    message.camouflage_moving = object.camouflage_moving ?? 0;
    message.camouflage_onFire = object.camouflage_onFire ?? 0;
    message.equipment_preset = object.equipment_preset ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

export function createBaseTankDefinition_RolesEntry(): TankDefinition_RolesEntry {
  return { key: 0, value: 0 };
}

export const TankDefinition_RolesEntry: MessageFns<TankDefinition_RolesEntry> = {
  encode(message: TankDefinition_RolesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TankDefinition_RolesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTankDefinition_RolesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TankDefinition_RolesEntry {
    return {
      key: globalThis.Number(assertSet("TankDefinition_RolesEntry.key", object.key)),
      value: globalThis.Number(assertSet("TankDefinition_RolesEntry.value", object.value)),
    };
  },

  toJSON(message: TankDefinition_RolesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TankDefinition_RolesEntry>, I>>(base?: I): TankDefinition_RolesEntry {
    return TankDefinition_RolesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TankDefinition_RolesEntry>, I>>(object: I): TankDefinition_RolesEntry {
    const message = createBaseTankDefinition_RolesEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

export function createBaseResearchCost(): ResearchCost {
  return { research_cost_type: undefined };
}

export const ResearchCost: MessageFns<ResearchCost> = {
  encode(message: ResearchCost, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.research_cost_type?.$case) {
      case "xp":
        writer.uint32(8).uint32(message.research_cost_type.value);
        break;
      case "seasonal_tokens":
        ResearchCostSeasonalTokens.encode(message.research_cost_type.value, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResearchCost {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResearchCost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.research_cost_type = { $case: "xp", value: reader.uint32() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.research_cost_type = {
            $case: "seasonal_tokens",
            value: ResearchCostSeasonalTokens.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResearchCost {
    return {
      research_cost_type: isSet(object.xp)
        ? { $case: "xp", value: globalThis.Number(object.xp) }
        : isSet(object.seasonal_tokens)
        ? { $case: "seasonal_tokens", value: ResearchCostSeasonalTokens.fromJSON(object.seasonal_tokens) }
        : undefined,
    };
  },

  toJSON(message: ResearchCost): unknown {
    const obj: any = {};
    if (message.research_cost_type?.$case === "xp") {
      obj.xp = Math.round(message.research_cost_type.value);
    }
    if (message.research_cost_type?.$case === "seasonal_tokens") {
      obj.seasonal_tokens = ResearchCostSeasonalTokens.toJSON(message.research_cost_type.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResearchCost>, I>>(base?: I): ResearchCost {
    return ResearchCost.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResearchCost>, I>>(object: I): ResearchCost {
    const message = createBaseResearchCost();
    if (
      object.research_cost_type?.$case === "xp" &&
      object.research_cost_type?.value !== undefined &&
      object.research_cost_type?.value !== null
    ) {
      message.research_cost_type = { $case: "xp", value: object.research_cost_type.value };
    }
    if (
      object.research_cost_type?.$case === "seasonal_tokens" &&
      object.research_cost_type?.value !== undefined &&
      object.research_cost_type?.value !== null
    ) {
      message.research_cost_type = {
        $case: "seasonal_tokens",
        value: ResearchCostSeasonalTokens.fromPartial(object.research_cost_type.value),
      };
    }
    return message;
  },
};

export function createBaseResearchCostSeasonalTokens(): ResearchCostSeasonalTokens {
  return { season: 0, tokens: 0 };
}

export const ResearchCostSeasonalTokens: MessageFns<ResearchCostSeasonalTokens> = {
  encode(message: ResearchCostSeasonalTokens, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.season !== 0) {
      writer.uint32(8).uint32(message.season);
    }
    if (message.tokens !== 0) {
      writer.uint32(16).uint32(message.tokens);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResearchCostSeasonalTokens {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResearchCostSeasonalTokens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.season = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tokens = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResearchCostSeasonalTokens {
    return {
      season: globalThis.Number(assertSet("ResearchCostSeasonalTokens.season", object.season)),
      tokens: globalThis.Number(assertSet("ResearchCostSeasonalTokens.tokens", object.tokens)),
    };
  },

  toJSON(message: ResearchCostSeasonalTokens): unknown {
    const obj: any = {};
    if (message.season !== 0) {
      obj.season = Math.round(message.season);
    }
    if (message.tokens !== 0) {
      obj.tokens = Math.round(message.tokens);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResearchCostSeasonalTokens>, I>>(base?: I): ResearchCostSeasonalTokens {
    return ResearchCostSeasonalTokens.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResearchCostSeasonalTokens>, I>>(object: I): ResearchCostSeasonalTokens {
    const message = createBaseResearchCostSeasonalTokens();
    message.season = object.season ?? 0;
    message.tokens = object.tokens ?? 0;
    return message;
  },
};

export function createBaseTankPrice(): TankPrice {
  return { type: 0, value: 0 };
}

export const TankPrice: MessageFns<TankPrice> = {
  encode(message: TankPrice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TankPrice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTankPrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TankPrice {
    return {
      type: tankPriceTypeFromJSON(assertSet("TankPrice.type", object.type)),
      value: globalThis.Number(assertSet("TankPrice.value", object.value)),
    };
  },

  toJSON(message: TankPrice): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = tankPriceTypeToJSON(message.type);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TankPrice>, I>>(base?: I): TankPrice {
    return TankPrice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TankPrice>, I>>(object: I): TankPrice {
    const message = createBaseTankPrice();
    message.type = object.type ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

export function createBaseTrackDefinition(): TrackDefinition {
  return {
    id: 0,
    tier: 0,
    name: createBaseI18nString(),
    weight: 0,
    traverse_speed: 0,
    research_cost: undefined,
    dispersion_move: 0,
    dispersion_traverse: 0,
    resistance_hard: 0,
    resistance_medium: 0,
    resistance_soft: 0,
    unlocks: [],
  };
}

export const TrackDefinition: MessageFns<TrackDefinition> = {
  encode(message: TrackDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.tier !== 0) {
      writer.uint32(16).uint32(message.tier);
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(26).fork()).join();
    }
    if (message.weight !== 0) {
      writer.uint32(32).uint32(message.weight);
    }
    if (message.traverse_speed !== 0) {
      writer.uint32(45).float(message.traverse_speed);
    }
    if (message.research_cost !== undefined) {
      ResearchCost.encode(message.research_cost, writer.uint32(50).fork()).join();
    }
    if (message.dispersion_move !== 0) {
      writer.uint32(61).float(message.dispersion_move);
    }
    if (message.dispersion_traverse !== 0) {
      writer.uint32(69).float(message.dispersion_traverse);
    }
    if (message.resistance_hard !== 0) {
      writer.uint32(77).float(message.resistance_hard);
    }
    if (message.resistance_medium !== 0) {
      writer.uint32(85).float(message.resistance_medium);
    }
    if (message.resistance_soft !== 0) {
      writer.uint32(93).float(message.resistance_soft);
    }
    for (const v of message.unlocks) {
      Unlock.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.traverse_speed = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.research_cost = ResearchCost.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.dispersion_move = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.dispersion_traverse = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.resistance_hard = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.resistance_medium = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.resistance_soft = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.unlocks.push(Unlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackDefinition {
    return {
      id: globalThis.Number(assertSet("TrackDefinition.id", object.id)),
      tier: globalThis.Number(assertSet("TrackDefinition.tier", object.tier)),
      name: I18nString.fromJSON(assertSet("TrackDefinition.name", object.name)),
      weight: globalThis.Number(assertSet("TrackDefinition.weight", object.weight)),
      traverse_speed: globalThis.Number(assertSet("TrackDefinition.traverse_speed", object.traverse_speed)),
      research_cost: isSet(object.research_cost) ? ResearchCost.fromJSON(object.research_cost) : undefined,
      dispersion_move: globalThis.Number(assertSet("TrackDefinition.dispersion_move", object.dispersion_move)),
      dispersion_traverse: globalThis.Number(
        assertSet("TrackDefinition.dispersion_traverse", object.dispersion_traverse),
      ),
      resistance_hard: globalThis.Number(assertSet("TrackDefinition.resistance_hard", object.resistance_hard)),
      resistance_medium: globalThis.Number(assertSet("TrackDefinition.resistance_medium", object.resistance_medium)),
      resistance_soft: globalThis.Number(assertSet("TrackDefinition.resistance_soft", object.resistance_soft)),
      unlocks: globalThis.Array.isArray(object?.unlocks) ? object.unlocks.map((e: any) => Unlock.fromJSON(e)) : [],
    };
  },

  toJSON(message: TrackDefinition): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.traverse_speed !== 0) {
      obj.traverse_speed = message.traverse_speed;
    }
    if (message.research_cost !== undefined) {
      obj.research_cost = ResearchCost.toJSON(message.research_cost);
    }
    if (message.dispersion_move !== 0) {
      obj.dispersion_move = message.dispersion_move;
    }
    if (message.dispersion_traverse !== 0) {
      obj.dispersion_traverse = message.dispersion_traverse;
    }
    if (message.resistance_hard !== 0) {
      obj.resistance_hard = message.resistance_hard;
    }
    if (message.resistance_medium !== 0) {
      obj.resistance_medium = message.resistance_medium;
    }
    if (message.resistance_soft !== 0) {
      obj.resistance_soft = message.resistance_soft;
    }
    if (message.unlocks?.length) {
      obj.unlocks = message.unlocks.map((e) => Unlock.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackDefinition>, I>>(base?: I): TrackDefinition {
    return TrackDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackDefinition>, I>>(object: I): TrackDefinition {
    const message = createBaseTrackDefinition();
    message.id = object.id ?? 0;
    message.tier = object.tier ?? 0;
    message.name = (object.name !== undefined && object.name !== null)
      ? I18nString.fromPartial(object.name)
      : createBaseI18nString();
    message.weight = object.weight ?? 0;
    message.traverse_speed = object.traverse_speed ?? 0;
    message.research_cost = (object.research_cost !== undefined && object.research_cost !== null)
      ? ResearchCost.fromPartial(object.research_cost)
      : undefined;
    message.dispersion_move = object.dispersion_move ?? 0;
    message.dispersion_traverse = object.dispersion_traverse ?? 0;
    message.resistance_hard = object.resistance_hard ?? 0;
    message.resistance_medium = object.resistance_medium ?? 0;
    message.resistance_soft = object.resistance_soft ?? 0;
    message.unlocks = object.unlocks?.map((e) => Unlock.fromPartial(e)) || [];
    return message;
  },
};

export function createBaseEngineDefinition(): EngineDefinition {
  return {
    id: 0,
    name: createBaseI18nString(),
    research_cost: undefined,
    tier: 0,
    fire_chance: 0,
    power: 0,
    weight: 0,
    unlocks: [],
  };
}

export const EngineDefinition: MessageFns<EngineDefinition> = {
  encode(message: EngineDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(18).fork()).join();
    }
    if (message.research_cost !== undefined) {
      ResearchCost.encode(message.research_cost, writer.uint32(26).fork()).join();
    }
    if (message.tier !== 0) {
      writer.uint32(32).uint32(message.tier);
    }
    if (message.fire_chance !== 0) {
      writer.uint32(45).float(message.fire_chance);
    }
    if (message.power !== 0) {
      writer.uint32(48).uint32(message.power);
    }
    if (message.weight !== 0) {
      writer.uint32(56).uint32(message.weight);
    }
    for (const v of message.unlocks) {
      Unlock.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.research_cost = ResearchCost.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.fire_chance = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.power = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.unlocks.push(Unlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineDefinition {
    return {
      id: globalThis.Number(assertSet("EngineDefinition.id", object.id)),
      name: I18nString.fromJSON(assertSet("EngineDefinition.name", object.name)),
      research_cost: isSet(object.research_cost) ? ResearchCost.fromJSON(object.research_cost) : undefined,
      tier: globalThis.Number(assertSet("EngineDefinition.tier", object.tier)),
      fire_chance: globalThis.Number(assertSet("EngineDefinition.fire_chance", object.fire_chance)),
      power: globalThis.Number(assertSet("EngineDefinition.power", object.power)),
      weight: globalThis.Number(assertSet("EngineDefinition.weight", object.weight)),
      unlocks: globalThis.Array.isArray(object?.unlocks) ? object.unlocks.map((e: any) => Unlock.fromJSON(e)) : [],
    };
  },

  toJSON(message: EngineDefinition): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.research_cost !== undefined) {
      obj.research_cost = ResearchCost.toJSON(message.research_cost);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.fire_chance !== 0) {
      obj.fire_chance = message.fire_chance;
    }
    if (message.power !== 0) {
      obj.power = Math.round(message.power);
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.unlocks?.length) {
      obj.unlocks = message.unlocks.map((e) => Unlock.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EngineDefinition>, I>>(base?: I): EngineDefinition {
    return EngineDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EngineDefinition>, I>>(object: I): EngineDefinition {
    const message = createBaseEngineDefinition();
    message.id = object.id ?? 0;
    message.name = (object.name !== undefined && object.name !== null)
      ? I18nString.fromPartial(object.name)
      : createBaseI18nString();
    message.research_cost = (object.research_cost !== undefined && object.research_cost !== null)
      ? ResearchCost.fromPartial(object.research_cost)
      : undefined;
    message.tier = object.tier ?? 0;
    message.fire_chance = object.fire_chance ?? 0;
    message.power = object.power ?? 0;
    message.weight = object.weight ?? 0;
    message.unlocks = object.unlocks?.map((e) => Unlock.fromPartial(e)) || [];
    return message;
  },
};

export function createBaseTurretDefinition(): TurretDefinition {
  return {
    id: 0,
    health: 0,
    view_range: 0,
    traverse_speed: 0,
    research_cost: undefined,
    name: createBaseI18nString(),
    tier: 0,
    weight: 0,
    guns: [],
    unlocks: [],
  };
}

export const TurretDefinition: MessageFns<TurretDefinition> = {
  encode(message: TurretDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.health !== 0) {
      writer.uint32(16).uint32(message.health);
    }
    if (message.view_range !== 0) {
      writer.uint32(24).uint32(message.view_range);
    }
    if (message.traverse_speed !== 0) {
      writer.uint32(37).float(message.traverse_speed);
    }
    if (message.research_cost !== undefined) {
      ResearchCost.encode(message.research_cost, writer.uint32(42).fork()).join();
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(50).fork()).join();
    }
    if (message.tier !== 0) {
      writer.uint32(56).uint32(message.tier);
    }
    if (message.weight !== 0) {
      writer.uint32(64).uint32(message.weight);
    }
    for (const v of message.guns) {
      GunDefinition.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.unlocks) {
      Unlock.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurretDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurretDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.health = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.view_range = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.traverse_speed = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.research_cost = ResearchCost.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.guns.push(GunDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.unlocks.push(Unlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurretDefinition {
    return {
      id: globalThis.Number(assertSet("TurretDefinition.id", object.id)),
      health: globalThis.Number(assertSet("TurretDefinition.health", object.health)),
      view_range: globalThis.Number(assertSet("TurretDefinition.view_range", object.view_range)),
      traverse_speed: globalThis.Number(assertSet("TurretDefinition.traverse_speed", object.traverse_speed)),
      research_cost: isSet(object.research_cost) ? ResearchCost.fromJSON(object.research_cost) : undefined,
      name: I18nString.fromJSON(assertSet("TurretDefinition.name", object.name)),
      tier: globalThis.Number(assertSet("TurretDefinition.tier", object.tier)),
      weight: globalThis.Number(assertSet("TurretDefinition.weight", object.weight)),
      guns: globalThis.Array.isArray(object?.guns) ? object.guns.map((e: any) => GunDefinition.fromJSON(e)) : [],
      unlocks: globalThis.Array.isArray(object?.unlocks) ? object.unlocks.map((e: any) => Unlock.fromJSON(e)) : [],
    };
  },

  toJSON(message: TurretDefinition): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.health !== 0) {
      obj.health = Math.round(message.health);
    }
    if (message.view_range !== 0) {
      obj.view_range = Math.round(message.view_range);
    }
    if (message.traverse_speed !== 0) {
      obj.traverse_speed = message.traverse_speed;
    }
    if (message.research_cost !== undefined) {
      obj.research_cost = ResearchCost.toJSON(message.research_cost);
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.guns?.length) {
      obj.guns = message.guns.map((e) => GunDefinition.toJSON(e));
    }
    if (message.unlocks?.length) {
      obj.unlocks = message.unlocks.map((e) => Unlock.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurretDefinition>, I>>(base?: I): TurretDefinition {
    return TurretDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurretDefinition>, I>>(object: I): TurretDefinition {
    const message = createBaseTurretDefinition();
    message.id = object.id ?? 0;
    message.health = object.health ?? 0;
    message.view_range = object.view_range ?? 0;
    message.traverse_speed = object.traverse_speed ?? 0;
    message.research_cost = (object.research_cost !== undefined && object.research_cost !== null)
      ? ResearchCost.fromPartial(object.research_cost)
      : undefined;
    message.name = (object.name !== undefined && object.name !== null)
      ? I18nString.fromPartial(object.name)
      : createBaseI18nString();
    message.tier = object.tier ?? 0;
    message.weight = object.weight ?? 0;
    message.guns = object.guns?.map((e) => GunDefinition.fromPartial(e)) || [];
    message.unlocks = object.unlocks?.map((e) => Unlock.fromPartial(e)) || [];
    return message;
  },
};

export function createBaseGunDefinition(): GunDefinition {
  return { gun_type: undefined };
}

export const GunDefinition: MessageFns<GunDefinition> = {
  encode(message: GunDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.gun_type?.$case) {
      case "regular":
        GunDefinitionRegular.encode(message.gun_type.value, writer.uint32(10).fork()).join();
        break;
      case "auto_loader":
        GunDefinitionAutoLoader.encode(message.gun_type.value, writer.uint32(18).fork()).join();
        break;
      case "auto_reloader":
        GunDefinitionAutoReloader.encode(message.gun_type.value, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GunDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gun_type = { $case: "regular", value: GunDefinitionRegular.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gun_type = { $case: "auto_loader", value: GunDefinitionAutoLoader.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gun_type = {
            $case: "auto_reloader",
            value: GunDefinitionAutoReloader.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinition {
    return {
      gun_type: isSet(object.regular)
        ? { $case: "regular", value: GunDefinitionRegular.fromJSON(object.regular) }
        : isSet(object.auto_loader)
        ? { $case: "auto_loader", value: GunDefinitionAutoLoader.fromJSON(object.auto_loader) }
        : isSet(object.auto_reloader)
        ? { $case: "auto_reloader", value: GunDefinitionAutoReloader.fromJSON(object.auto_reloader) }
        : undefined,
    };
  },

  toJSON(message: GunDefinition): unknown {
    const obj: any = {};
    if (message.gun_type?.$case === "regular") {
      obj.regular = GunDefinitionRegular.toJSON(message.gun_type.value);
    }
    if (message.gun_type?.$case === "auto_loader") {
      obj.auto_loader = GunDefinitionAutoLoader.toJSON(message.gun_type.value);
    }
    if (message.gun_type?.$case === "auto_reloader") {
      obj.auto_reloader = GunDefinitionAutoReloader.toJSON(message.gun_type.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinition>, I>>(base?: I): GunDefinition {
    return GunDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinition>, I>>(object: I): GunDefinition {
    const message = createBaseGunDefinition();
    if (
      object.gun_type?.$case === "regular" && object.gun_type?.value !== undefined && object.gun_type?.value !== null
    ) {
      message.gun_type = { $case: "regular", value: GunDefinitionRegular.fromPartial(object.gun_type.value) };
    }
    if (
      object.gun_type?.$case === "auto_loader" &&
      object.gun_type?.value !== undefined &&
      object.gun_type?.value !== null
    ) {
      message.gun_type = { $case: "auto_loader", value: GunDefinitionAutoLoader.fromPartial(object.gun_type.value) };
    }
    if (
      object.gun_type?.$case === "auto_reloader" &&
      object.gun_type?.value !== undefined &&
      object.gun_type?.value !== null
    ) {
      message.gun_type = {
        $case: "auto_reloader",
        value: GunDefinitionAutoReloader.fromPartial(object.gun_type.value),
      };
    }
    return message;
  },
};

export function createBaseGunDefinitionRegular(): GunDefinitionRegular {
  return { base: createBaseGunDefinitionBase(), extension: createBaseGunDefinitionRegularProperties() };
}

export const GunDefinitionRegular: MessageFns<GunDefinitionRegular> = {
  encode(message: GunDefinitionRegular, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      GunDefinitionBase.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.extension !== undefined) {
      GunDefinitionRegularProperties.encode(message.extension, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GunDefinitionRegular {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinitionRegular();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = GunDefinitionBase.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.extension = GunDefinitionRegularProperties.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinitionRegular {
    return {
      base: GunDefinitionBase.fromJSON(assertSet("GunDefinitionRegular.base", object.base)),
      extension: GunDefinitionRegularProperties.fromJSON(assertSet("GunDefinitionRegular.extension", object.extension)),
    };
  },

  toJSON(message: GunDefinitionRegular): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = GunDefinitionBase.toJSON(message.base);
    }
    if (message.extension !== undefined) {
      obj.extension = GunDefinitionRegularProperties.toJSON(message.extension);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinitionRegular>, I>>(base?: I): GunDefinitionRegular {
    return GunDefinitionRegular.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinitionRegular>, I>>(object: I): GunDefinitionRegular {
    const message = createBaseGunDefinitionRegular();
    message.base = (object.base !== undefined && object.base !== null)
      ? GunDefinitionBase.fromPartial(object.base)
      : createBaseGunDefinitionBase();
    message.extension = (object.extension !== undefined && object.extension !== null)
      ? GunDefinitionRegularProperties.fromPartial(object.extension)
      : createBaseGunDefinitionRegularProperties();
    return message;
  },
};

export function createBaseGunDefinitionRegularProperties(): GunDefinitionRegularProperties {
  return { reload: 0 };
}

export const GunDefinitionRegularProperties: MessageFns<GunDefinitionRegularProperties> = {
  encode(message: GunDefinitionRegularProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reload !== 0) {
      writer.uint32(13).float(message.reload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GunDefinitionRegularProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinitionRegularProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.reload = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinitionRegularProperties {
    return { reload: globalThis.Number(assertSet("GunDefinitionRegularProperties.reload", object.reload)) };
  },

  toJSON(message: GunDefinitionRegularProperties): unknown {
    const obj: any = {};
    if (message.reload !== 0) {
      obj.reload = message.reload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinitionRegularProperties>, I>>(base?: I): GunDefinitionRegularProperties {
    return GunDefinitionRegularProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinitionRegularProperties>, I>>(
    object: I,
  ): GunDefinitionRegularProperties {
    const message = createBaseGunDefinitionRegularProperties();
    message.reload = object.reload ?? 0;
    return message;
  },
};

export function createBaseGunDefinitionAutoLoader(): GunDefinitionAutoLoader {
  return { base: createBaseGunDefinitionBase(), extension: createBaseGunDefinitionAutoLoaderProperties() };
}

export const GunDefinitionAutoLoader: MessageFns<GunDefinitionAutoLoader> = {
  encode(message: GunDefinitionAutoLoader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      GunDefinitionBase.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.extension !== undefined) {
      GunDefinitionAutoLoaderProperties.encode(message.extension, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GunDefinitionAutoLoader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinitionAutoLoader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = GunDefinitionBase.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.extension = GunDefinitionAutoLoaderProperties.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinitionAutoLoader {
    return {
      base: GunDefinitionBase.fromJSON(assertSet("GunDefinitionAutoLoader.base", object.base)),
      extension: GunDefinitionAutoLoaderProperties.fromJSON(
        assertSet("GunDefinitionAutoLoader.extension", object.extension),
      ),
    };
  },

  toJSON(message: GunDefinitionAutoLoader): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = GunDefinitionBase.toJSON(message.base);
    }
    if (message.extension !== undefined) {
      obj.extension = GunDefinitionAutoLoaderProperties.toJSON(message.extension);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinitionAutoLoader>, I>>(base?: I): GunDefinitionAutoLoader {
    return GunDefinitionAutoLoader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinitionAutoLoader>, I>>(object: I): GunDefinitionAutoLoader {
    const message = createBaseGunDefinitionAutoLoader();
    message.base = (object.base !== undefined && object.base !== null)
      ? GunDefinitionBase.fromPartial(object.base)
      : createBaseGunDefinitionBase();
    message.extension = (object.extension !== undefined && object.extension !== null)
      ? GunDefinitionAutoLoaderProperties.fromPartial(object.extension)
      : createBaseGunDefinitionAutoLoaderProperties();
    return message;
  },
};

export function createBaseGunDefinitionAutoLoaderProperties(): GunDefinitionAutoLoaderProperties {
  return { clip_reload: 0, intra_clip: 0, shell_count: 0 };
}

export const GunDefinitionAutoLoaderProperties: MessageFns<GunDefinitionAutoLoaderProperties> = {
  encode(message: GunDefinitionAutoLoaderProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clip_reload !== 0) {
      writer.uint32(13).float(message.clip_reload);
    }
    if (message.intra_clip !== 0) {
      writer.uint32(21).float(message.intra_clip);
    }
    if (message.shell_count !== 0) {
      writer.uint32(29).float(message.shell_count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GunDefinitionAutoLoaderProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinitionAutoLoaderProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.clip_reload = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.intra_clip = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.shell_count = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinitionAutoLoaderProperties {
    return {
      clip_reload: globalThis.Number(assertSet("GunDefinitionAutoLoaderProperties.clip_reload", object.clip_reload)),
      intra_clip: globalThis.Number(assertSet("GunDefinitionAutoLoaderProperties.intra_clip", object.intra_clip)),
      shell_count: globalThis.Number(assertSet("GunDefinitionAutoLoaderProperties.shell_count", object.shell_count)),
    };
  },

  toJSON(message: GunDefinitionAutoLoaderProperties): unknown {
    const obj: any = {};
    if (message.clip_reload !== 0) {
      obj.clip_reload = message.clip_reload;
    }
    if (message.intra_clip !== 0) {
      obj.intra_clip = message.intra_clip;
    }
    if (message.shell_count !== 0) {
      obj.shell_count = message.shell_count;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinitionAutoLoaderProperties>, I>>(
    base?: I,
  ): GunDefinitionAutoLoaderProperties {
    return GunDefinitionAutoLoaderProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinitionAutoLoaderProperties>, I>>(
    object: I,
  ): GunDefinitionAutoLoaderProperties {
    const message = createBaseGunDefinitionAutoLoaderProperties();
    message.clip_reload = object.clip_reload ?? 0;
    message.intra_clip = object.intra_clip ?? 0;
    message.shell_count = object.shell_count ?? 0;
    return message;
  },
};

export function createBaseGunDefinitionAutoReloader(): GunDefinitionAutoReloader {
  return { base: createBaseGunDefinitionBase(), extension: createBaseGunDefinitionAutoReloaderProperties() };
}

export const GunDefinitionAutoReloader: MessageFns<GunDefinitionAutoReloader> = {
  encode(message: GunDefinitionAutoReloader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== undefined) {
      GunDefinitionBase.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.extension !== undefined) {
      GunDefinitionAutoReloaderProperties.encode(message.extension, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GunDefinitionAutoReloader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinitionAutoReloader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = GunDefinitionBase.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.extension = GunDefinitionAutoReloaderProperties.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinitionAutoReloader {
    return {
      base: GunDefinitionBase.fromJSON(assertSet("GunDefinitionAutoReloader.base", object.base)),
      extension: GunDefinitionAutoReloaderProperties.fromJSON(
        assertSet("GunDefinitionAutoReloader.extension", object.extension),
      ),
    };
  },

  toJSON(message: GunDefinitionAutoReloader): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = GunDefinitionBase.toJSON(message.base);
    }
    if (message.extension !== undefined) {
      obj.extension = GunDefinitionAutoReloaderProperties.toJSON(message.extension);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinitionAutoReloader>, I>>(base?: I): GunDefinitionAutoReloader {
    return GunDefinitionAutoReloader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinitionAutoReloader>, I>>(object: I): GunDefinitionAutoReloader {
    const message = createBaseGunDefinitionAutoReloader();
    message.base = (object.base !== undefined && object.base !== null)
      ? GunDefinitionBase.fromPartial(object.base)
      : createBaseGunDefinitionBase();
    message.extension = (object.extension !== undefined && object.extension !== null)
      ? GunDefinitionAutoReloaderProperties.fromPartial(object.extension)
      : createBaseGunDefinitionAutoReloaderProperties();
    return message;
  },
};

export function createBaseGunDefinitionAutoReloaderProperties(): GunDefinitionAutoReloaderProperties {
  return { shell_reloads: [], intra_clip: 0, shell_count: 0 };
}

export const GunDefinitionAutoReloaderProperties: MessageFns<GunDefinitionAutoReloaderProperties> = {
  encode(message: GunDefinitionAutoReloaderProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.shell_reloads) {
      writer.float(v);
    }
    writer.join();
    if (message.intra_clip !== 0) {
      writer.uint32(21).float(message.intra_clip);
    }
    if (message.shell_count !== 0) {
      writer.uint32(29).float(message.shell_count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GunDefinitionAutoReloaderProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinitionAutoReloaderProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.shell_reloads.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.shell_reloads.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.intra_clip = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.shell_count = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinitionAutoReloaderProperties {
    return {
      shell_reloads: globalThis.Array.isArray(object?.shell_reloads)
        ? object.shell_reloads.map((e: any) => globalThis.Number(e))
        : [],
      intra_clip: globalThis.Number(assertSet("GunDefinitionAutoReloaderProperties.intra_clip", object.intra_clip)),
      shell_count: globalThis.Number(assertSet("GunDefinitionAutoReloaderProperties.shell_count", object.shell_count)),
    };
  },

  toJSON(message: GunDefinitionAutoReloaderProperties): unknown {
    const obj: any = {};
    if (message.shell_reloads?.length) {
      obj.shell_reloads = message.shell_reloads;
    }
    if (message.intra_clip !== 0) {
      obj.intra_clip = message.intra_clip;
    }
    if (message.shell_count !== 0) {
      obj.shell_count = message.shell_count;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinitionAutoReloaderProperties>, I>>(
    base?: I,
  ): GunDefinitionAutoReloaderProperties {
    return GunDefinitionAutoReloaderProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinitionAutoReloaderProperties>, I>>(
    object: I,
  ): GunDefinitionAutoReloaderProperties {
    const message = createBaseGunDefinitionAutoReloaderProperties();
    message.shell_reloads = object.shell_reloads?.map((e) => e) || [];
    message.intra_clip = object.intra_clip ?? 0;
    message.shell_count = object.shell_count ?? 0;
    return message;
  },
};

export function createBaseGunDefinitionBase(): GunDefinitionBase {
  return {
    id: 0,
    rotation_speed: 0,
    research_cost: undefined,
    weight: 0,
    name: createBaseI18nString(),
    tier: 0,
    shells: [],
    camouflage_loss: 0,
    aim_time: 0,
    dispersion_base: 0,
    dispersion_traverse: 0,
    dispersion_shot: 0,
    dispersion_damaged: 0,
    unlocks: [],
    shell_capacity: 0,
  };
}

export const GunDefinitionBase: MessageFns<GunDefinitionBase> = {
  encode(message: GunDefinitionBase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.rotation_speed !== 0) {
      writer.uint32(21).float(message.rotation_speed);
    }
    if (message.research_cost !== undefined) {
      ResearchCost.encode(message.research_cost, writer.uint32(26).fork()).join();
    }
    if (message.weight !== 0) {
      writer.uint32(32).uint32(message.weight);
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(42).fork()).join();
    }
    if (message.tier !== 0) {
      writer.uint32(48).uint32(message.tier);
    }
    for (const v of message.shells) {
      ShellDefinition.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.camouflage_loss !== 0) {
      writer.uint32(69).float(message.camouflage_loss);
    }
    if (message.aim_time !== 0) {
      writer.uint32(77).float(message.aim_time);
    }
    if (message.dispersion_base !== 0) {
      writer.uint32(85).float(message.dispersion_base);
    }
    if (message.dispersion_traverse !== 0) {
      writer.uint32(93).float(message.dispersion_traverse);
    }
    if (message.dispersion_shot !== 0) {
      writer.uint32(101).float(message.dispersion_shot);
    }
    if (message.dispersion_damaged !== 0) {
      writer.uint32(109).float(message.dispersion_damaged);
    }
    for (const v of message.unlocks) {
      Unlock.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.shell_capacity !== 0) {
      writer.uint32(120).uint32(message.shell_capacity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GunDefinitionBase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunDefinitionBase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.rotation_speed = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.research_cost = ResearchCost.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.shells.push(ShellDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.camouflage_loss = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.aim_time = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.dispersion_base = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.dispersion_traverse = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.dispersion_shot = reader.float();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.dispersion_damaged = reader.float();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.unlocks.push(Unlock.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.shell_capacity = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunDefinitionBase {
    return {
      id: globalThis.Number(assertSet("GunDefinitionBase.id", object.id)),
      rotation_speed: globalThis.Number(assertSet("GunDefinitionBase.rotation_speed", object.rotation_speed)),
      research_cost: isSet(object.research_cost) ? ResearchCost.fromJSON(object.research_cost) : undefined,
      weight: globalThis.Number(assertSet("GunDefinitionBase.weight", object.weight)),
      name: I18nString.fromJSON(assertSet("GunDefinitionBase.name", object.name)),
      tier: globalThis.Number(assertSet("GunDefinitionBase.tier", object.tier)),
      shells: globalThis.Array.isArray(object?.shells)
        ? object.shells.map((e: any) => ShellDefinition.fromJSON(e))
        : [],
      camouflage_loss: globalThis.Number(assertSet("GunDefinitionBase.camouflage_loss", object.camouflage_loss)),
      aim_time: globalThis.Number(assertSet("GunDefinitionBase.aim_time", object.aim_time)),
      dispersion_base: globalThis.Number(assertSet("GunDefinitionBase.dispersion_base", object.dispersion_base)),
      dispersion_traverse: globalThis.Number(
        assertSet("GunDefinitionBase.dispersion_traverse", object.dispersion_traverse),
      ),
      dispersion_shot: globalThis.Number(assertSet("GunDefinitionBase.dispersion_shot", object.dispersion_shot)),
      dispersion_damaged: globalThis.Number(
        assertSet("GunDefinitionBase.dispersion_damaged", object.dispersion_damaged),
      ),
      unlocks: globalThis.Array.isArray(object?.unlocks) ? object.unlocks.map((e: any) => Unlock.fromJSON(e)) : [],
      shell_capacity: globalThis.Number(assertSet("GunDefinitionBase.shell_capacity", object.shell_capacity)),
    };
  },

  toJSON(message: GunDefinitionBase): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.rotation_speed !== 0) {
      obj.rotation_speed = message.rotation_speed;
    }
    if (message.research_cost !== undefined) {
      obj.research_cost = ResearchCost.toJSON(message.research_cost);
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.shells?.length) {
      obj.shells = message.shells.map((e) => ShellDefinition.toJSON(e));
    }
    if (message.camouflage_loss !== 0) {
      obj.camouflage_loss = message.camouflage_loss;
    }
    if (message.aim_time !== 0) {
      obj.aim_time = message.aim_time;
    }
    if (message.dispersion_base !== 0) {
      obj.dispersion_base = message.dispersion_base;
    }
    if (message.dispersion_traverse !== 0) {
      obj.dispersion_traverse = message.dispersion_traverse;
    }
    if (message.dispersion_shot !== 0) {
      obj.dispersion_shot = message.dispersion_shot;
    }
    if (message.dispersion_damaged !== 0) {
      obj.dispersion_damaged = message.dispersion_damaged;
    }
    if (message.unlocks?.length) {
      obj.unlocks = message.unlocks.map((e) => Unlock.toJSON(e));
    }
    if (message.shell_capacity !== 0) {
      obj.shell_capacity = Math.round(message.shell_capacity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunDefinitionBase>, I>>(base?: I): GunDefinitionBase {
    return GunDefinitionBase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunDefinitionBase>, I>>(object: I): GunDefinitionBase {
    const message = createBaseGunDefinitionBase();
    message.id = object.id ?? 0;
    message.rotation_speed = object.rotation_speed ?? 0;
    message.research_cost = (object.research_cost !== undefined && object.research_cost !== null)
      ? ResearchCost.fromPartial(object.research_cost)
      : undefined;
    message.weight = object.weight ?? 0;
    message.name = (object.name !== undefined && object.name !== null)
      ? I18nString.fromPartial(object.name)
      : createBaseI18nString();
    message.tier = object.tier ?? 0;
    message.shells = object.shells?.map((e) => ShellDefinition.fromPartial(e)) || [];
    message.camouflage_loss = object.camouflage_loss ?? 0;
    message.aim_time = object.aim_time ?? 0;
    message.dispersion_base = object.dispersion_base ?? 0;
    message.dispersion_traverse = object.dispersion_traverse ?? 0;
    message.dispersion_shot = object.dispersion_shot ?? 0;
    message.dispersion_damaged = object.dispersion_damaged ?? 0;
    message.unlocks = object.unlocks?.map((e) => Unlock.fromPartial(e)) || [];
    message.shell_capacity = object.shell_capacity ?? 0;
    return message;
  },
};

export function createBaseShellDefinition(): ShellDefinition {
  return {
    id: 0,
    name: createBaseI18nString(),
    velocity: 0,
    armor_damage: 0,
    module_damage: 0,
    caliber: 0,
    icon: "",
    penetration: createBaseShellPenetration(),
    type: 0,
    normalization: undefined,
    ricochet: undefined,
    explosion_radius: undefined,
    range: 0,
  };
}

export const ShellDefinition: MessageFns<ShellDefinition> = {
  encode(message: ShellDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== undefined) {
      I18nString.encode(message.name, writer.uint32(18).fork()).join();
    }
    if (message.velocity !== 0) {
      writer.uint32(24).uint32(message.velocity);
    }
    if (message.armor_damage !== 0) {
      writer.uint32(32).uint32(message.armor_damage);
    }
    if (message.module_damage !== 0) {
      writer.uint32(40).uint32(message.module_damage);
    }
    if (message.caliber !== 0) {
      writer.uint32(53).float(message.caliber);
    }
    if (message.icon !== "") {
      writer.uint32(58).string(message.icon);
    }
    if (message.penetration !== undefined) {
      ShellPenetration.encode(message.penetration, writer.uint32(66).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.normalization !== undefined && message.normalization !== undefined) {
      writer.uint32(85).float(message.normalization);
    }
    if (message.ricochet !== undefined && message.ricochet !== undefined) {
      writer.uint32(93).float(message.ricochet);
    }
    if (message.explosion_radius !== undefined && message.explosion_radius !== undefined) {
      writer.uint32(101).float(message.explosion_radius);
    }
    if (message.range !== 0) {
      writer.uint32(104).uint32(message.range);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = I18nString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.velocity = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.armor_damage = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.module_damage = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.caliber = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.icon = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.penetration = ShellPenetration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.normalization = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.ricochet = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.explosion_radius = reader.float();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.range = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellDefinition {
    return {
      id: globalThis.Number(assertSet("ShellDefinition.id", object.id)),
      name: I18nString.fromJSON(assertSet("ShellDefinition.name", object.name)),
      velocity: globalThis.Number(assertSet("ShellDefinition.velocity", object.velocity)),
      armor_damage: globalThis.Number(assertSet("ShellDefinition.armor_damage", object.armor_damage)),
      module_damage: globalThis.Number(assertSet("ShellDefinition.module_damage", object.module_damage)),
      caliber: globalThis.Number(assertSet("ShellDefinition.caliber", object.caliber)),
      icon: globalThis.String(assertSet("ShellDefinition.icon", object.icon)),
      penetration: ShellPenetration.fromJSON(assertSet("ShellDefinition.penetration", object.penetration)),
      type: shellTypeFromJSON(assertSet("ShellDefinition.type", object.type)),
      normalization: isSet(object.normalization) ? globalThis.Number(object.normalization) : undefined,
      ricochet: isSet(object.ricochet) ? globalThis.Number(object.ricochet) : undefined,
      explosion_radius: isSet(object.explosion_radius) ? globalThis.Number(object.explosion_radius) : undefined,
      range: globalThis.Number(assertSet("ShellDefinition.range", object.range)),
    };
  },

  toJSON(message: ShellDefinition): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined) {
      obj.name = I18nString.toJSON(message.name);
    }
    if (message.velocity !== 0) {
      obj.velocity = Math.round(message.velocity);
    }
    if (message.armor_damage !== 0) {
      obj.armor_damage = Math.round(message.armor_damage);
    }
    if (message.module_damage !== 0) {
      obj.module_damage = Math.round(message.module_damage);
    }
    if (message.caliber !== 0) {
      obj.caliber = message.caliber;
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.penetration !== undefined) {
      obj.penetration = ShellPenetration.toJSON(message.penetration);
    }
    if (message.type !== 0) {
      obj.type = shellTypeToJSON(message.type);
    }
    if (message.normalization !== undefined && message.normalization !== undefined) {
      obj.normalization = message.normalization;
    }
    if (message.ricochet !== undefined && message.ricochet !== undefined) {
      obj.ricochet = message.ricochet;
    }
    if (message.explosion_radius !== undefined && message.explosion_radius !== undefined) {
      obj.explosion_radius = message.explosion_radius;
    }
    if (message.range !== 0) {
      obj.range = Math.round(message.range);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellDefinition>, I>>(base?: I): ShellDefinition {
    return ShellDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellDefinition>, I>>(object: I): ShellDefinition {
    const message = createBaseShellDefinition();
    message.id = object.id ?? 0;
    message.name = (object.name !== undefined && object.name !== null)
      ? I18nString.fromPartial(object.name)
      : createBaseI18nString();
    message.velocity = object.velocity ?? 0;
    message.armor_damage = object.armor_damage ?? 0;
    message.module_damage = object.module_damage ?? 0;
    message.caliber = object.caliber ?? 0;
    message.icon = object.icon ?? "";
    message.penetration = (object.penetration !== undefined && object.penetration !== null)
      ? ShellPenetration.fromPartial(object.penetration)
      : createBaseShellPenetration();
    message.type = object.type ?? 0;
    message.normalization = object.normalization ?? undefined;
    message.ricochet = object.ricochet ?? undefined;
    message.explosion_radius = object.explosion_radius ?? undefined;
    message.range = object.range ?? 0;
    return message;
  },
};

export function createBaseShellPenetration(): ShellPenetration {
  return { near: 0, far: 0 };
}

export const ShellPenetration: MessageFns<ShellPenetration> = {
  encode(message: ShellPenetration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.near !== 0) {
      writer.uint32(13).float(message.near);
    }
    if (message.far !== 0) {
      writer.uint32(21).float(message.far);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellPenetration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellPenetration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.near = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.far = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellPenetration {
    return {
      near: globalThis.Number(assertSet("ShellPenetration.near", object.near)),
      far: globalThis.Number(assertSet("ShellPenetration.far", object.far)),
    };
  },

  toJSON(message: ShellPenetration): unknown {
    const obj: any = {};
    if (message.near !== 0) {
      obj.near = message.near;
    }
    if (message.far !== 0) {
      obj.far = message.far;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellPenetration>, I>>(base?: I): ShellPenetration {
    return ShellPenetration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellPenetration>, I>>(object: I): ShellPenetration {
    const message = createBaseShellPenetration();
    message.near = object.near ?? 0;
    message.far = object.far ?? 0;
    return message;
  },
};

export function createBaseUnlock(): Unlock {
  return { id: 0, type: 0, cost: createBaseUnlockCost() };
}

export const Unlock: MessageFns<Unlock> = {
  encode(message: Unlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.cost !== undefined) {
      UnlockCost.encode(message.cost, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Unlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cost = UnlockCost.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Unlock {
    return {
      id: globalThis.Number(assertSet("Unlock.id", object.id)),
      type: moduleTypeFromJSON(assertSet("Unlock.type", object.type)),
      cost: UnlockCost.fromJSON(assertSet("Unlock.cost", object.cost)),
    };
  },

  toJSON(message: Unlock): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== 0) {
      obj.type = moduleTypeToJSON(message.type);
    }
    if (message.cost !== undefined) {
      obj.cost = UnlockCost.toJSON(message.cost);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Unlock>, I>>(base?: I): Unlock {
    return Unlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Unlock>, I>>(object: I): Unlock {
    const message = createBaseUnlock();
    message.id = object.id ?? 0;
    message.type = object.type ?? 0;
    message.cost = (object.cost !== undefined && object.cost !== null)
      ? UnlockCost.fromPartial(object.cost)
      : createBaseUnlockCost();
    return message;
  },
};

export function createBaseUnlockCost(): UnlockCost {
  return { type: "", value: 0 };
}

export const UnlockCost: MessageFns<UnlockCost> = {
  encode(message: UnlockCost, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnlockCost {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockCost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnlockCost {
    return {
      type: globalThis.String(assertSet("UnlockCost.type", object.type)),
      value: globalThis.Number(assertSet("UnlockCost.value", object.value)),
    };
  },

  toJSON(message: UnlockCost): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnlockCost>, I>>(base?: I): UnlockCost {
    return UnlockCost.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnlockCost>, I>>(object: I): UnlockCost {
    const message = createBaseUnlockCost();
    message.type = object.type ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

export function createBaseCrew(): Crew {
  return { type: 0, count: 0, substitute: [] };
}

export const Crew: MessageFns<Crew> = {
  encode(message: Crew, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    writer.uint32(26).fork();
    for (const v of message.substitute) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Crew {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrew();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.substitute.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.substitute.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Crew {
    return {
      type: crewTypeFromJSON(assertSet("Crew.type", object.type)),
      count: globalThis.Number(assertSet("Crew.count", object.count)),
      substitute: globalThis.Array.isArray(object?.substitute)
        ? object.substitute.map((e: any) => crewTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: Crew): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = crewTypeToJSON(message.type);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.substitute?.length) {
      obj.substitute = message.substitute.map((e) => crewTypeToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Crew>, I>>(base?: I): Crew {
    return Crew.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Crew>, I>>(object: I): Crew {
    const message = createBaseCrew();
    message.type = object.type ?? 0;
    message.count = object.count ?? 0;
    message.substitute = object.substitute?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

function assertSet<T>(field: string, value: T | undefined): T {
  if (!isSet(value)) {
    throw new TypeError(`Required field ${field} is not set`);
  }

  return value as T;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
