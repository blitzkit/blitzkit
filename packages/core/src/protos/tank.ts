// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.2
//   protoc               v5.28.2
// source: packages/core/src/protos/tank.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { I18n } from "./i18n";

export const protobufPackage = "blitzkit";

export enum CrewType {
  COMMANDER = 0,
  DRIVER = 1,
  GUNNER_1 = 2,
  GUNNER_2 = 3,
  LOADER_1 = 4,
  LOADER_2 = 5,
}

export function crewTypeFromJSON(object: any): CrewType {
  switch (object) {
    case 0:
    case "COMMANDER":
      return CrewType.COMMANDER;
    case 1:
    case "DRIVER":
      return CrewType.DRIVER;
    case 2:
    case "GUNNER_1":
      return CrewType.GUNNER_1;
    case 3:
    case "GUNNER_2":
      return CrewType.GUNNER_2;
    case 4:
    case "LOADER_1":
      return CrewType.LOADER_1;
    case 5:
    case "LOADER_2":
      return CrewType.LOADER_2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CrewType");
  }
}

export function crewTypeToJSON(object: CrewType): string {
  switch (object) {
    case CrewType.COMMANDER:
      return "COMMANDER";
    case CrewType.DRIVER:
      return "DRIVER";
    case CrewType.GUNNER_1:
      return "GUNNER_1";
    case CrewType.GUNNER_2:
      return "GUNNER_2";
    case CrewType.LOADER_1:
      return "LOADER_1";
    case CrewType.LOADER_2:
      return "LOADER_2";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CrewType");
  }
}

export interface Tank {
  id: string;
  name: I18n;
  set: string;
  class: string;
  /** nations have been renamed to factions */
  faction: string;
  turret_rotator_health: ModuleHealth;
  surveying_device_health: ModuleHealth;
  gun_health: ModuleHealth;
  chassis_health: ModuleHealth;
  ammo_bay_health: ModuleHealth;
  engine_health: ModuleHealth;
  fuel_tank_health: ModuleHealth;
  crew_health: CrewHealth[];
  max_health: number;
  health_burn_per_sec: number;
  fire_starting_chance: number;
  concealment_stationary: number;
  concealment_moving: number;
  concealment_factor_at_shot: number;
  turret_turn_rate: number;
  circular_vision_radius: number;
  shells: Shell[];
  reload_time: number;
  dispersion_angle: number;
  shot_dispersion_factor: number;
  turret_rotation_dispersion_factor: number;
  aiming_time: number;
  gun_turn_rate: number;
  mass: number;
  engine_power: number;
  forward_max_speed: number;
  backward_max_speed: number;
  rotation_speed: number;
  terrain_resistance_hard: number;
  brake_force: number;
}

export interface CrewHealth {
  type: CrewType;
  max_health: number;
}

export interface Shell {
  speed: number;
  gravity: number;
  armor_damage: number;
  module_damage: number;
  caliber: number;
  piercing_power: number;
  piercing_power_500m: number;
  normalization: number;
  max_distance: number;
  ricochet_angle: number;
  piercing_power_loss_factor_by_distance: number;
  explosion_radius: number;
  max_count: number;
}

export interface ModuleHealth {
  /** max health, assigned by default at the start of the battle */
  max_health: number;
  /** max health reached as the module regenerates after breaking */
  max_regen_health: number;
  /**
   * the range from 0 to this where the module is "red" and doesn't function
   * all the while healing; after surpassing this, the "yellow" phase is reached
   * undefined for modules like ammo bays
   */
  hysteresis_health?:
    | number
    | undefined;
  /**
   * the heal rate (per second); this won't apply if the health is at or above
   * max_regen hence always leaving it in the "yellow" phase until repaired
   */
  health_regen_per_sec: number;
  /**
   * damage received (per second) to the modules when caught on fire; this can
   * be undefined for some modules like the gun or chassis
   */
  health_burn_per_sec?: number | undefined;
}

function createBaseTank(): Tank {
  return {
    id: "",
    name: createBaseI18n(),
    set: "",
    class: "",
    faction: "",
    turret_rotator_health: createBaseModuleHealth(),
    surveying_device_health: createBaseModuleHealth(),
    gun_health: createBaseModuleHealth(),
    chassis_health: createBaseModuleHealth(),
    ammo_bay_health: createBaseModuleHealth(),
    engine_health: createBaseModuleHealth(),
    fuel_tank_health: createBaseModuleHealth(),
    crew_health: [],
    max_health: 0,
    health_burn_per_sec: 0,
    fire_starting_chance: 0,
    concealment_stationary: 0,
    concealment_moving: 0,
    concealment_factor_at_shot: 0,
    turret_turn_rate: 0,
    circular_vision_radius: 0,
    shells: [],
    reload_time: 0,
    dispersion_angle: 0,
    shot_dispersion_factor: 0,
    turret_rotation_dispersion_factor: 0,
    aiming_time: 0,
    gun_turn_rate: 0,
    mass: 0,
    engine_power: 0,
    forward_max_speed: 0,
    backward_max_speed: 0,
    rotation_speed: 0,
    terrain_resistance_hard: 0,
    brake_force: 0,
  };
}

export const Tank: MessageFns<Tank> = {
  encode(message: Tank, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      I18n.encode(message.name, writer.uint32(18).fork()).join();
    }
    if (message.set !== "") {
      writer.uint32(26).string(message.set);
    }
    if (message.class !== "") {
      writer.uint32(34).string(message.class);
    }
    if (message.faction !== "") {
      writer.uint32(42).string(message.faction);
    }
    if (message.turret_rotator_health !== undefined) {
      ModuleHealth.encode(message.turret_rotator_health, writer.uint32(50).fork()).join();
    }
    if (message.surveying_device_health !== undefined) {
      ModuleHealth.encode(message.surveying_device_health, writer.uint32(58).fork()).join();
    }
    if (message.gun_health !== undefined) {
      ModuleHealth.encode(message.gun_health, writer.uint32(66).fork()).join();
    }
    if (message.chassis_health !== undefined) {
      ModuleHealth.encode(message.chassis_health, writer.uint32(74).fork()).join();
    }
    if (message.ammo_bay_health !== undefined) {
      ModuleHealth.encode(message.ammo_bay_health, writer.uint32(82).fork()).join();
    }
    if (message.engine_health !== undefined) {
      ModuleHealth.encode(message.engine_health, writer.uint32(90).fork()).join();
    }
    if (message.fuel_tank_health !== undefined) {
      ModuleHealth.encode(message.fuel_tank_health, writer.uint32(98).fork()).join();
    }
    for (const v of message.crew_health) {
      CrewHealth.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.max_health !== 0) {
      writer.uint32(117).float(message.max_health);
    }
    if (message.health_burn_per_sec !== 0) {
      writer.uint32(125).float(message.health_burn_per_sec);
    }
    if (message.fire_starting_chance !== 0) {
      writer.uint32(133).float(message.fire_starting_chance);
    }
    if (message.concealment_stationary !== 0) {
      writer.uint32(141).float(message.concealment_stationary);
    }
    if (message.concealment_moving !== 0) {
      writer.uint32(149).float(message.concealment_moving);
    }
    if (message.concealment_factor_at_shot !== 0) {
      writer.uint32(157).float(message.concealment_factor_at_shot);
    }
    if (message.turret_turn_rate !== 0) {
      writer.uint32(165).float(message.turret_turn_rate);
    }
    if (message.circular_vision_radius !== 0) {
      writer.uint32(173).float(message.circular_vision_radius);
    }
    for (const v of message.shells) {
      Shell.encode(v!, writer.uint32(178).fork()).join();
    }
    if (message.reload_time !== 0) {
      writer.uint32(189).float(message.reload_time);
    }
    if (message.dispersion_angle !== 0) {
      writer.uint32(197).float(message.dispersion_angle);
    }
    if (message.shot_dispersion_factor !== 0) {
      writer.uint32(205).float(message.shot_dispersion_factor);
    }
    if (message.turret_rotation_dispersion_factor !== 0) {
      writer.uint32(213).float(message.turret_rotation_dispersion_factor);
    }
    if (message.aiming_time !== 0) {
      writer.uint32(221).float(message.aiming_time);
    }
    if (message.gun_turn_rate !== 0) {
      writer.uint32(229).float(message.gun_turn_rate);
    }
    if (message.mass !== 0) {
      writer.uint32(237).float(message.mass);
    }
    if (message.engine_power !== 0) {
      writer.uint32(245).float(message.engine_power);
    }
    if (message.forward_max_speed !== 0) {
      writer.uint32(253).float(message.forward_max_speed);
    }
    if (message.backward_max_speed !== 0) {
      writer.uint32(261).float(message.backward_max_speed);
    }
    if (message.rotation_speed !== 0) {
      writer.uint32(269).float(message.rotation_speed);
    }
    if (message.terrain_resistance_hard !== 0) {
      writer.uint32(277).float(message.terrain_resistance_hard);
    }
    if (message.brake_force !== 0) {
      writer.uint32(285).float(message.brake_force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tank {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTank();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = I18n.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.set = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.class = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.faction = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.turret_rotator_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.surveying_device_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.gun_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.chassis_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.ammo_bay_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.engine_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.fuel_tank_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.crew_health.push(CrewHealth.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 117) {
            break;
          }

          message.max_health = reader.float();
          continue;
        }
        case 15: {
          if (tag !== 125) {
            break;
          }

          message.health_burn_per_sec = reader.float();
          continue;
        }
        case 16: {
          if (tag !== 133) {
            break;
          }

          message.fire_starting_chance = reader.float();
          continue;
        }
        case 17: {
          if (tag !== 141) {
            break;
          }

          message.concealment_stationary = reader.float();
          continue;
        }
        case 18: {
          if (tag !== 149) {
            break;
          }

          message.concealment_moving = reader.float();
          continue;
        }
        case 19: {
          if (tag !== 157) {
            break;
          }

          message.concealment_factor_at_shot = reader.float();
          continue;
        }
        case 20: {
          if (tag !== 165) {
            break;
          }

          message.turret_turn_rate = reader.float();
          continue;
        }
        case 21: {
          if (tag !== 173) {
            break;
          }

          message.circular_vision_radius = reader.float();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.shells.push(Shell.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 189) {
            break;
          }

          message.reload_time = reader.float();
          continue;
        }
        case 24: {
          if (tag !== 197) {
            break;
          }

          message.dispersion_angle = reader.float();
          continue;
        }
        case 25: {
          if (tag !== 205) {
            break;
          }

          message.shot_dispersion_factor = reader.float();
          continue;
        }
        case 26: {
          if (tag !== 213) {
            break;
          }

          message.turret_rotation_dispersion_factor = reader.float();
          continue;
        }
        case 27: {
          if (tag !== 221) {
            break;
          }

          message.aiming_time = reader.float();
          continue;
        }
        case 28: {
          if (tag !== 229) {
            break;
          }

          message.gun_turn_rate = reader.float();
          continue;
        }
        case 29: {
          if (tag !== 237) {
            break;
          }

          message.mass = reader.float();
          continue;
        }
        case 30: {
          if (tag !== 245) {
            break;
          }

          message.engine_power = reader.float();
          continue;
        }
        case 31: {
          if (tag !== 253) {
            break;
          }

          message.forward_max_speed = reader.float();
          continue;
        }
        case 32: {
          if (tag !== 261) {
            break;
          }

          message.backward_max_speed = reader.float();
          continue;
        }
        case 33: {
          if (tag !== 269) {
            break;
          }

          message.rotation_speed = reader.float();
          continue;
        }
        case 34: {
          if (tag !== 277) {
            break;
          }

          message.terrain_resistance_hard = reader.float();
          continue;
        }
        case 35: {
          if (tag !== 285) {
            break;
          }

          message.brake_force = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tank {
    return {
      id: globalThis.String(assertSet("Tank.id", object.id)),
      name: I18n.fromJSON(assertSet("Tank.name", object.name)),
      set: globalThis.String(assertSet("Tank.set", object.set)),
      class: globalThis.String(assertSet("Tank.class", object.class)),
      faction: globalThis.String(assertSet("Tank.faction", object.faction)),
      turret_rotator_health: ModuleHealth.fromJSON(
        assertSet("Tank.turret_rotator_health", object.turret_rotator_health),
      ),
      surveying_device_health: ModuleHealth.fromJSON(
        assertSet("Tank.surveying_device_health", object.surveying_device_health),
      ),
      gun_health: ModuleHealth.fromJSON(assertSet("Tank.gun_health", object.gun_health)),
      chassis_health: ModuleHealth.fromJSON(assertSet("Tank.chassis_health", object.chassis_health)),
      ammo_bay_health: ModuleHealth.fromJSON(assertSet("Tank.ammo_bay_health", object.ammo_bay_health)),
      engine_health: ModuleHealth.fromJSON(assertSet("Tank.engine_health", object.engine_health)),
      fuel_tank_health: ModuleHealth.fromJSON(assertSet("Tank.fuel_tank_health", object.fuel_tank_health)),
      crew_health: globalThis.Array.isArray(object?.crew_health)
        ? object.crew_health.map((e: any) => CrewHealth.fromJSON(e))
        : [],
      max_health: globalThis.Number(assertSet("Tank.max_health", object.max_health)),
      health_burn_per_sec: globalThis.Number(assertSet("Tank.health_burn_per_sec", object.health_burn_per_sec)),
      fire_starting_chance: globalThis.Number(assertSet("Tank.fire_starting_chance", object.fire_starting_chance)),
      concealment_stationary: globalThis.Number(
        assertSet("Tank.concealment_stationary", object.concealment_stationary),
      ),
      concealment_moving: globalThis.Number(assertSet("Tank.concealment_moving", object.concealment_moving)),
      concealment_factor_at_shot: globalThis.Number(
        assertSet("Tank.concealment_factor_at_shot", object.concealment_factor_at_shot),
      ),
      turret_turn_rate: globalThis.Number(assertSet("Tank.turret_turn_rate", object.turret_turn_rate)),
      circular_vision_radius: globalThis.Number(
        assertSet("Tank.circular_vision_radius", object.circular_vision_radius),
      ),
      shells: globalThis.Array.isArray(object?.shells) ? object.shells.map((e: any) => Shell.fromJSON(e)) : [],
      reload_time: globalThis.Number(assertSet("Tank.reload_time", object.reload_time)),
      dispersion_angle: globalThis.Number(assertSet("Tank.dispersion_angle", object.dispersion_angle)),
      shot_dispersion_factor: globalThis.Number(
        assertSet("Tank.shot_dispersion_factor", object.shot_dispersion_factor),
      ),
      turret_rotation_dispersion_factor: globalThis.Number(
        assertSet("Tank.turret_rotation_dispersion_factor", object.turret_rotation_dispersion_factor),
      ),
      aiming_time: globalThis.Number(assertSet("Tank.aiming_time", object.aiming_time)),
      gun_turn_rate: globalThis.Number(assertSet("Tank.gun_turn_rate", object.gun_turn_rate)),
      mass: globalThis.Number(assertSet("Tank.mass", object.mass)),
      engine_power: globalThis.Number(assertSet("Tank.engine_power", object.engine_power)),
      forward_max_speed: globalThis.Number(assertSet("Tank.forward_max_speed", object.forward_max_speed)),
      backward_max_speed: globalThis.Number(assertSet("Tank.backward_max_speed", object.backward_max_speed)),
      rotation_speed: globalThis.Number(assertSet("Tank.rotation_speed", object.rotation_speed)),
      terrain_resistance_hard: globalThis.Number(
        assertSet("Tank.terrain_resistance_hard", object.terrain_resistance_hard),
      ),
      brake_force: globalThis.Number(assertSet("Tank.brake_force", object.brake_force)),
    };
  },

  toJSON(message: Tank): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = I18n.toJSON(message.name);
    }
    if (message.set !== "") {
      obj.set = message.set;
    }
    if (message.class !== "") {
      obj.class = message.class;
    }
    if (message.faction !== "") {
      obj.faction = message.faction;
    }
    if (message.turret_rotator_health !== undefined) {
      obj.turret_rotator_health = ModuleHealth.toJSON(message.turret_rotator_health);
    }
    if (message.surveying_device_health !== undefined) {
      obj.surveying_device_health = ModuleHealth.toJSON(message.surveying_device_health);
    }
    if (message.gun_health !== undefined) {
      obj.gun_health = ModuleHealth.toJSON(message.gun_health);
    }
    if (message.chassis_health !== undefined) {
      obj.chassis_health = ModuleHealth.toJSON(message.chassis_health);
    }
    if (message.ammo_bay_health !== undefined) {
      obj.ammo_bay_health = ModuleHealth.toJSON(message.ammo_bay_health);
    }
    if (message.engine_health !== undefined) {
      obj.engine_health = ModuleHealth.toJSON(message.engine_health);
    }
    if (message.fuel_tank_health !== undefined) {
      obj.fuel_tank_health = ModuleHealth.toJSON(message.fuel_tank_health);
    }
    if (message.crew_health?.length) {
      obj.crew_health = message.crew_health.map((e) => CrewHealth.toJSON(e));
    }
    if (message.max_health !== 0) {
      obj.max_health = message.max_health;
    }
    if (message.health_burn_per_sec !== 0) {
      obj.health_burn_per_sec = message.health_burn_per_sec;
    }
    if (message.fire_starting_chance !== 0) {
      obj.fire_starting_chance = message.fire_starting_chance;
    }
    if (message.concealment_stationary !== 0) {
      obj.concealment_stationary = message.concealment_stationary;
    }
    if (message.concealment_moving !== 0) {
      obj.concealment_moving = message.concealment_moving;
    }
    if (message.concealment_factor_at_shot !== 0) {
      obj.concealment_factor_at_shot = message.concealment_factor_at_shot;
    }
    if (message.turret_turn_rate !== 0) {
      obj.turret_turn_rate = message.turret_turn_rate;
    }
    if (message.circular_vision_radius !== 0) {
      obj.circular_vision_radius = message.circular_vision_radius;
    }
    if (message.shells?.length) {
      obj.shells = message.shells.map((e) => Shell.toJSON(e));
    }
    if (message.reload_time !== 0) {
      obj.reload_time = message.reload_time;
    }
    if (message.dispersion_angle !== 0) {
      obj.dispersion_angle = message.dispersion_angle;
    }
    if (message.shot_dispersion_factor !== 0) {
      obj.shot_dispersion_factor = message.shot_dispersion_factor;
    }
    if (message.turret_rotation_dispersion_factor !== 0) {
      obj.turret_rotation_dispersion_factor = message.turret_rotation_dispersion_factor;
    }
    if (message.aiming_time !== 0) {
      obj.aiming_time = message.aiming_time;
    }
    if (message.gun_turn_rate !== 0) {
      obj.gun_turn_rate = message.gun_turn_rate;
    }
    if (message.mass !== 0) {
      obj.mass = message.mass;
    }
    if (message.engine_power !== 0) {
      obj.engine_power = message.engine_power;
    }
    if (message.forward_max_speed !== 0) {
      obj.forward_max_speed = message.forward_max_speed;
    }
    if (message.backward_max_speed !== 0) {
      obj.backward_max_speed = message.backward_max_speed;
    }
    if (message.rotation_speed !== 0) {
      obj.rotation_speed = message.rotation_speed;
    }
    if (message.terrain_resistance_hard !== 0) {
      obj.terrain_resistance_hard = message.terrain_resistance_hard;
    }
    if (message.brake_force !== 0) {
      obj.brake_force = message.brake_force;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tank>, I>>(base?: I): Tank {
    return Tank.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tank>, I>>(object: I): Tank {
    const message = createBaseTank();
    message.id = object.id ?? "";
    message.name = (object.name !== undefined && object.name !== null)
      ? I18n.fromPartial(object.name)
      : createBaseI18n();
    message.set = object.set ?? "";
    message.class = object.class ?? "";
    message.faction = object.faction ?? "";
    message.turret_rotator_health =
      (object.turret_rotator_health !== undefined && object.turret_rotator_health !== null)
        ? ModuleHealth.fromPartial(object.turret_rotator_health)
        : createBaseModuleHealth();
    message.surveying_device_health =
      (object.surveying_device_health !== undefined && object.surveying_device_health !== null)
        ? ModuleHealth.fromPartial(object.surveying_device_health)
        : createBaseModuleHealth();
    message.gun_health = (object.gun_health !== undefined && object.gun_health !== null)
      ? ModuleHealth.fromPartial(object.gun_health)
      : createBaseModuleHealth();
    message.chassis_health = (object.chassis_health !== undefined && object.chassis_health !== null)
      ? ModuleHealth.fromPartial(object.chassis_health)
      : createBaseModuleHealth();
    message.ammo_bay_health = (object.ammo_bay_health !== undefined && object.ammo_bay_health !== null)
      ? ModuleHealth.fromPartial(object.ammo_bay_health)
      : createBaseModuleHealth();
    message.engine_health = (object.engine_health !== undefined && object.engine_health !== null)
      ? ModuleHealth.fromPartial(object.engine_health)
      : createBaseModuleHealth();
    message.fuel_tank_health = (object.fuel_tank_health !== undefined && object.fuel_tank_health !== null)
      ? ModuleHealth.fromPartial(object.fuel_tank_health)
      : createBaseModuleHealth();
    message.crew_health = object.crew_health?.map((e) => CrewHealth.fromPartial(e)) || [];
    message.max_health = object.max_health ?? 0;
    message.health_burn_per_sec = object.health_burn_per_sec ?? 0;
    message.fire_starting_chance = object.fire_starting_chance ?? 0;
    message.concealment_stationary = object.concealment_stationary ?? 0;
    message.concealment_moving = object.concealment_moving ?? 0;
    message.concealment_factor_at_shot = object.concealment_factor_at_shot ?? 0;
    message.turret_turn_rate = object.turret_turn_rate ?? 0;
    message.circular_vision_radius = object.circular_vision_radius ?? 0;
    message.shells = object.shells?.map((e) => Shell.fromPartial(e)) || [];
    message.reload_time = object.reload_time ?? 0;
    message.dispersion_angle = object.dispersion_angle ?? 0;
    message.shot_dispersion_factor = object.shot_dispersion_factor ?? 0;
    message.turret_rotation_dispersion_factor = object.turret_rotation_dispersion_factor ?? 0;
    message.aiming_time = object.aiming_time ?? 0;
    message.gun_turn_rate = object.gun_turn_rate ?? 0;
    message.mass = object.mass ?? 0;
    message.engine_power = object.engine_power ?? 0;
    message.forward_max_speed = object.forward_max_speed ?? 0;
    message.backward_max_speed = object.backward_max_speed ?? 0;
    message.rotation_speed = object.rotation_speed ?? 0;
    message.terrain_resistance_hard = object.terrain_resistance_hard ?? 0;
    message.brake_force = object.brake_force ?? 0;
    return message;
  },
};

function createBaseCrewHealth(): CrewHealth {
  return { type: 0, max_health: 0 };
}

export const CrewHealth: MessageFns<CrewHealth> = {
  encode(message: CrewHealth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.max_health !== 0) {
      writer.uint32(21).float(message.max_health);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrewHealth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrewHealth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.max_health = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrewHealth {
    return {
      type: crewTypeFromJSON(assertSet("CrewHealth.type", object.type)),
      max_health: globalThis.Number(assertSet("CrewHealth.max_health", object.max_health)),
    };
  },

  toJSON(message: CrewHealth): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = crewTypeToJSON(message.type);
    }
    if (message.max_health !== 0) {
      obj.max_health = message.max_health;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrewHealth>, I>>(base?: I): CrewHealth {
    return CrewHealth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrewHealth>, I>>(object: I): CrewHealth {
    const message = createBaseCrewHealth();
    message.type = object.type ?? 0;
    message.max_health = object.max_health ?? 0;
    return message;
  },
};

function createBaseShell(): Shell {
  return {
    speed: 0,
    gravity: 0,
    armor_damage: 0,
    module_damage: 0,
    caliber: 0,
    piercing_power: 0,
    piercing_power_500m: 0,
    normalization: 0,
    max_distance: 0,
    ricochet_angle: 0,
    piercing_power_loss_factor_by_distance: 0,
    explosion_radius: 0,
    max_count: 0,
  };
}

export const Shell: MessageFns<Shell> = {
  encode(message: Shell, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.speed !== 0) {
      writer.uint32(13).float(message.speed);
    }
    if (message.gravity !== 0) {
      writer.uint32(21).float(message.gravity);
    }
    if (message.armor_damage !== 0) {
      writer.uint32(29).float(message.armor_damage);
    }
    if (message.module_damage !== 0) {
      writer.uint32(37).float(message.module_damage);
    }
    if (message.caliber !== 0) {
      writer.uint32(45).float(message.caliber);
    }
    if (message.piercing_power !== 0) {
      writer.uint32(53).float(message.piercing_power);
    }
    if (message.piercing_power_500m !== 0) {
      writer.uint32(61).float(message.piercing_power_500m);
    }
    if (message.normalization !== 0) {
      writer.uint32(69).float(message.normalization);
    }
    if (message.max_distance !== 0) {
      writer.uint32(77).float(message.max_distance);
    }
    if (message.ricochet_angle !== 0) {
      writer.uint32(85).float(message.ricochet_angle);
    }
    if (message.piercing_power_loss_factor_by_distance !== 0) {
      writer.uint32(93).float(message.piercing_power_loss_factor_by_distance);
    }
    if (message.explosion_radius !== 0) {
      writer.uint32(101).float(message.explosion_radius);
    }
    if (message.max_count !== 0) {
      writer.uint32(104).int32(message.max_count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Shell {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.speed = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.gravity = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.armor_damage = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.module_damage = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.caliber = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.piercing_power = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.piercing_power_500m = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.normalization = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.max_distance = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.ricochet_angle = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.piercing_power_loss_factor_by_distance = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.explosion_radius = reader.float();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.max_count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Shell {
    return {
      speed: globalThis.Number(assertSet("Shell.speed", object.speed)),
      gravity: globalThis.Number(assertSet("Shell.gravity", object.gravity)),
      armor_damage: globalThis.Number(assertSet("Shell.armor_damage", object.armor_damage)),
      module_damage: globalThis.Number(assertSet("Shell.module_damage", object.module_damage)),
      caliber: globalThis.Number(assertSet("Shell.caliber", object.caliber)),
      piercing_power: globalThis.Number(assertSet("Shell.piercing_power", object.piercing_power)),
      piercing_power_500m: globalThis.Number(assertSet("Shell.piercing_power_500m", object.piercing_power_500m)),
      normalization: globalThis.Number(assertSet("Shell.normalization", object.normalization)),
      max_distance: globalThis.Number(assertSet("Shell.max_distance", object.max_distance)),
      ricochet_angle: globalThis.Number(assertSet("Shell.ricochet_angle", object.ricochet_angle)),
      piercing_power_loss_factor_by_distance: globalThis.Number(
        assertSet("Shell.piercing_power_loss_factor_by_distance", object.piercing_power_loss_factor_by_distance),
      ),
      explosion_radius: globalThis.Number(assertSet("Shell.explosion_radius", object.explosion_radius)),
      max_count: globalThis.Number(assertSet("Shell.max_count", object.max_count)),
    };
  },

  toJSON(message: Shell): unknown {
    const obj: any = {};
    if (message.speed !== 0) {
      obj.speed = message.speed;
    }
    if (message.gravity !== 0) {
      obj.gravity = message.gravity;
    }
    if (message.armor_damage !== 0) {
      obj.armor_damage = message.armor_damage;
    }
    if (message.module_damage !== 0) {
      obj.module_damage = message.module_damage;
    }
    if (message.caliber !== 0) {
      obj.caliber = message.caliber;
    }
    if (message.piercing_power !== 0) {
      obj.piercing_power = message.piercing_power;
    }
    if (message.piercing_power_500m !== 0) {
      obj.piercing_power_500m = message.piercing_power_500m;
    }
    if (message.normalization !== 0) {
      obj.normalization = message.normalization;
    }
    if (message.max_distance !== 0) {
      obj.max_distance = message.max_distance;
    }
    if (message.ricochet_angle !== 0) {
      obj.ricochet_angle = message.ricochet_angle;
    }
    if (message.piercing_power_loss_factor_by_distance !== 0) {
      obj.piercing_power_loss_factor_by_distance = message.piercing_power_loss_factor_by_distance;
    }
    if (message.explosion_radius !== 0) {
      obj.explosion_radius = message.explosion_radius;
    }
    if (message.max_count !== 0) {
      obj.max_count = Math.round(message.max_count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Shell>, I>>(base?: I): Shell {
    return Shell.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Shell>, I>>(object: I): Shell {
    const message = createBaseShell();
    message.speed = object.speed ?? 0;
    message.gravity = object.gravity ?? 0;
    message.armor_damage = object.armor_damage ?? 0;
    message.module_damage = object.module_damage ?? 0;
    message.caliber = object.caliber ?? 0;
    message.piercing_power = object.piercing_power ?? 0;
    message.piercing_power_500m = object.piercing_power_500m ?? 0;
    message.normalization = object.normalization ?? 0;
    message.max_distance = object.max_distance ?? 0;
    message.ricochet_angle = object.ricochet_angle ?? 0;
    message.piercing_power_loss_factor_by_distance = object.piercing_power_loss_factor_by_distance ?? 0;
    message.explosion_radius = object.explosion_radius ?? 0;
    message.max_count = object.max_count ?? 0;
    return message;
  },
};

function createBaseModuleHealth(): ModuleHealth {
  return {
    max_health: 0,
    max_regen_health: 0,
    hysteresis_health: undefined,
    health_regen_per_sec: 0,
    health_burn_per_sec: undefined,
  };
}

export const ModuleHealth: MessageFns<ModuleHealth> = {
  encode(message: ModuleHealth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.max_health !== 0) {
      writer.uint32(13).float(message.max_health);
    }
    if (message.max_regen_health !== 0) {
      writer.uint32(21).float(message.max_regen_health);
    }
    if (message.hysteresis_health !== undefined && message.hysteresis_health !== undefined) {
      writer.uint32(29).float(message.hysteresis_health);
    }
    if (message.health_regen_per_sec !== 0) {
      writer.uint32(37).float(message.health_regen_per_sec);
    }
    if (message.health_burn_per_sec !== undefined && message.health_burn_per_sec !== undefined) {
      writer.uint32(45).float(message.health_burn_per_sec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModuleHealth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModuleHealth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.max_health = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.max_regen_health = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.hysteresis_health = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.health_regen_per_sec = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.health_burn_per_sec = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModuleHealth {
    return {
      max_health: globalThis.Number(assertSet("ModuleHealth.max_health", object.max_health)),
      max_regen_health: globalThis.Number(assertSet("ModuleHealth.max_regen_health", object.max_regen_health)),
      hysteresis_health: isSet(object.hysteresis_health) ? globalThis.Number(object.hysteresis_health) : undefined,
      health_regen_per_sec: globalThis.Number(
        assertSet("ModuleHealth.health_regen_per_sec", object.health_regen_per_sec),
      ),
      health_burn_per_sec: isSet(object.health_burn_per_sec)
        ? globalThis.Number(object.health_burn_per_sec)
        : undefined,
    };
  },

  toJSON(message: ModuleHealth): unknown {
    const obj: any = {};
    if (message.max_health !== 0) {
      obj.max_health = message.max_health;
    }
    if (message.max_regen_health !== 0) {
      obj.max_regen_health = message.max_regen_health;
    }
    if (message.hysteresis_health !== undefined && message.hysteresis_health !== undefined) {
      obj.hysteresis_health = message.hysteresis_health;
    }
    if (message.health_regen_per_sec !== 0) {
      obj.health_regen_per_sec = message.health_regen_per_sec;
    }
    if (message.health_burn_per_sec !== undefined && message.health_burn_per_sec !== undefined) {
      obj.health_burn_per_sec = message.health_burn_per_sec;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModuleHealth>, I>>(base?: I): ModuleHealth {
    return ModuleHealth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModuleHealth>, I>>(object: I): ModuleHealth {
    const message = createBaseModuleHealth();
    message.max_health = object.max_health ?? 0;
    message.max_regen_health = object.max_regen_health ?? 0;
    message.hysteresis_health = object.hysteresis_health ?? undefined;
    message.health_regen_per_sec = object.health_regen_per_sec ?? 0;
    message.health_burn_per_sec = object.health_burn_per_sec ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

function assertSet<T>(field: string, value: T | undefined): T {
  if (!isSet(value)) {
    throw new TypeError(`Required field ${field} is not set`);
  }

  return value as T;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
