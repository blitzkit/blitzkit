// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.2
//   protoc               v5.28.2
// source: packages/core/src/protos/tank.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "blitzkit";

export interface Tank {
  turret_rotator_health: ModuleHealth;
  surveying_device_health: ModuleHealth;
  gun_health: ModuleHealth;
  chassis_health: ModuleHealth;
  ammo_bay_health: ModuleHealth;
  engine_health: ModuleHealth;
  fuel_tank_health: ModuleHealth;
  crew_healths: { [key: string]: number };
  max_health: number;
  concealment_stationary: number;
  concealment_moving: number;
  concealment_on_shot: number;
  up_pitch_limits: PitchLimit[];
  down_pitch_limits: PitchLimit[];
  turret_turn_rate: number;
  spotting_range: number;
  shells: Shell[];
  reload_time: number;
  dispersion_stationary: number;
  dispersion_turret_rotation: number;
  dispersion_moving: number;
  dispersion_hull_rotation: number;
  gun_turn_rate: number;
  mass: number;
  engine_power: number;
  max_speed_forwards: number;
  max_speed_backwards: number;
  rotation_speed: number;
  terrain_resistance_hard: number;
  terrain_resistance_medium: number;
  terrain_resistance_soft: number;
  brake_force: number;
}

export interface Tank_CrewHealthsEntry {
  key: string;
  value: number;
}

export interface Shell {
  speed: number;
  armor_damage: number;
  module_damage: number;
  caliber: number;
  penetration: number;
  penetration_500m: number;
  normalization: number;
  range: number;
  ricochet: number;
  penetration_loss_by_distance: number;
  explosion_radius: number;
  max_count: number;
}

export interface PitchLimit {
  angle: number;
  value: number;
}

export interface ModuleHealth {
  /** max health, assigned by default at the start of the battle */
  max: number;
  /** max health reached as the module regenerates after breaking */
  max_regen: number;
  /**
   * the range from 0 to this where the module is "red" and doesn't function
   * all the while healing; after surpassing this, the "yellow" phase is reached
   */
  hysteresis: number;
  /**
   * the heal rate (per second); this won't apply if the health is at or above
   * max_regen hence always leaving it in the "yellow" phase until repaired
   */
  heal_rate: number;
  /** damage received (per second) to the modules when caught on fire */
  burn_rate: number;
}

function createBaseTank(): Tank {
  return {
    turret_rotator_health: createBaseModuleHealth(),
    surveying_device_health: createBaseModuleHealth(),
    gun_health: createBaseModuleHealth(),
    chassis_health: createBaseModuleHealth(),
    ammo_bay_health: createBaseModuleHealth(),
    engine_health: createBaseModuleHealth(),
    fuel_tank_health: createBaseModuleHealth(),
    crew_healths: {},
    max_health: 0,
    concealment_stationary: 0,
    concealment_moving: 0,
    concealment_on_shot: 0,
    up_pitch_limits: [],
    down_pitch_limits: [],
    turret_turn_rate: 0,
    spotting_range: 0,
    shells: [],
    reload_time: 0,
    dispersion_stationary: 0,
    dispersion_turret_rotation: 0,
    dispersion_moving: 0,
    dispersion_hull_rotation: 0,
    gun_turn_rate: 0,
    mass: 0,
    engine_power: 0,
    max_speed_forwards: 0,
    max_speed_backwards: 0,
    rotation_speed: 0,
    terrain_resistance_hard: 0,
    terrain_resistance_medium: 0,
    terrain_resistance_soft: 0,
    brake_force: 0,
  };
}

export const Tank: MessageFns<Tank> = {
  encode(message: Tank, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.turret_rotator_health !== undefined) {
      ModuleHealth.encode(message.turret_rotator_health, writer.uint32(10).fork()).join();
    }
    if (message.surveying_device_health !== undefined) {
      ModuleHealth.encode(message.surveying_device_health, writer.uint32(18).fork()).join();
    }
    if (message.gun_health !== undefined) {
      ModuleHealth.encode(message.gun_health, writer.uint32(26).fork()).join();
    }
    if (message.chassis_health !== undefined) {
      ModuleHealth.encode(message.chassis_health, writer.uint32(34).fork()).join();
    }
    if (message.ammo_bay_health !== undefined) {
      ModuleHealth.encode(message.ammo_bay_health, writer.uint32(42).fork()).join();
    }
    if (message.engine_health !== undefined) {
      ModuleHealth.encode(message.engine_health, writer.uint32(50).fork()).join();
    }
    if (message.fuel_tank_health !== undefined) {
      ModuleHealth.encode(message.fuel_tank_health, writer.uint32(58).fork()).join();
    }
    Object.entries(message.crew_healths).forEach(([key, value]) => {
      Tank_CrewHealthsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.max_health !== 0) {
      writer.uint32(77).float(message.max_health);
    }
    if (message.concealment_stationary !== 0) {
      writer.uint32(85).float(message.concealment_stationary);
    }
    if (message.concealment_moving !== 0) {
      writer.uint32(93).float(message.concealment_moving);
    }
    if (message.concealment_on_shot !== 0) {
      writer.uint32(101).float(message.concealment_on_shot);
    }
    for (const v of message.up_pitch_limits) {
      PitchLimit.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.down_pitch_limits) {
      PitchLimit.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.turret_turn_rate !== 0) {
      writer.uint32(125).float(message.turret_turn_rate);
    }
    if (message.spotting_range !== 0) {
      writer.uint32(133).float(message.spotting_range);
    }
    for (const v of message.shells) {
      Shell.encode(v!, writer.uint32(138).fork()).join();
    }
    if (message.reload_time !== 0) {
      writer.uint32(149).float(message.reload_time);
    }
    if (message.dispersion_stationary !== 0) {
      writer.uint32(157).float(message.dispersion_stationary);
    }
    if (message.dispersion_turret_rotation !== 0) {
      writer.uint32(165).float(message.dispersion_turret_rotation);
    }
    if (message.dispersion_moving !== 0) {
      writer.uint32(173).float(message.dispersion_moving);
    }
    if (message.dispersion_hull_rotation !== 0) {
      writer.uint32(181).float(message.dispersion_hull_rotation);
    }
    if (message.gun_turn_rate !== 0) {
      writer.uint32(189).float(message.gun_turn_rate);
    }
    if (message.mass !== 0) {
      writer.uint32(197).float(message.mass);
    }
    if (message.engine_power !== 0) {
      writer.uint32(205).float(message.engine_power);
    }
    if (message.max_speed_forwards !== 0) {
      writer.uint32(213).float(message.max_speed_forwards);
    }
    if (message.max_speed_backwards !== 0) {
      writer.uint32(221).float(message.max_speed_backwards);
    }
    if (message.rotation_speed !== 0) {
      writer.uint32(229).float(message.rotation_speed);
    }
    if (message.terrain_resistance_hard !== 0) {
      writer.uint32(237).float(message.terrain_resistance_hard);
    }
    if (message.terrain_resistance_medium !== 0) {
      writer.uint32(245).float(message.terrain_resistance_medium);
    }
    if (message.terrain_resistance_soft !== 0) {
      writer.uint32(253).float(message.terrain_resistance_soft);
    }
    if (message.brake_force !== 0) {
      writer.uint32(261).float(message.brake_force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tank {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTank();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.turret_rotator_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.surveying_device_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gun_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chassis_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ammo_bay_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.engine_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.fuel_tank_health = ModuleHealth.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = Tank_CrewHealthsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.crew_healths[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.max_health = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.concealment_stationary = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.concealment_moving = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.concealment_on_shot = reader.float();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.up_pitch_limits.push(PitchLimit.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.down_pitch_limits.push(PitchLimit.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 125) {
            break;
          }

          message.turret_turn_rate = reader.float();
          continue;
        }
        case 16: {
          if (tag !== 133) {
            break;
          }

          message.spotting_range = reader.float();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.shells.push(Shell.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 149) {
            break;
          }

          message.reload_time = reader.float();
          continue;
        }
        case 19: {
          if (tag !== 157) {
            break;
          }

          message.dispersion_stationary = reader.float();
          continue;
        }
        case 20: {
          if (tag !== 165) {
            break;
          }

          message.dispersion_turret_rotation = reader.float();
          continue;
        }
        case 21: {
          if (tag !== 173) {
            break;
          }

          message.dispersion_moving = reader.float();
          continue;
        }
        case 22: {
          if (tag !== 181) {
            break;
          }

          message.dispersion_hull_rotation = reader.float();
          continue;
        }
        case 23: {
          if (tag !== 189) {
            break;
          }

          message.gun_turn_rate = reader.float();
          continue;
        }
        case 24: {
          if (tag !== 197) {
            break;
          }

          message.mass = reader.float();
          continue;
        }
        case 25: {
          if (tag !== 205) {
            break;
          }

          message.engine_power = reader.float();
          continue;
        }
        case 26: {
          if (tag !== 213) {
            break;
          }

          message.max_speed_forwards = reader.float();
          continue;
        }
        case 27: {
          if (tag !== 221) {
            break;
          }

          message.max_speed_backwards = reader.float();
          continue;
        }
        case 28: {
          if (tag !== 229) {
            break;
          }

          message.rotation_speed = reader.float();
          continue;
        }
        case 29: {
          if (tag !== 237) {
            break;
          }

          message.terrain_resistance_hard = reader.float();
          continue;
        }
        case 30: {
          if (tag !== 245) {
            break;
          }

          message.terrain_resistance_medium = reader.float();
          continue;
        }
        case 31: {
          if (tag !== 253) {
            break;
          }

          message.terrain_resistance_soft = reader.float();
          continue;
        }
        case 32: {
          if (tag !== 261) {
            break;
          }

          message.brake_force = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tank {
    return {
      turret_rotator_health: ModuleHealth.fromJSON(
        assertSet("Tank.turret_rotator_health", object.turret_rotator_health),
      ),
      surveying_device_health: ModuleHealth.fromJSON(
        assertSet("Tank.surveying_device_health", object.surveying_device_health),
      ),
      gun_health: ModuleHealth.fromJSON(assertSet("Tank.gun_health", object.gun_health)),
      chassis_health: ModuleHealth.fromJSON(assertSet("Tank.chassis_health", object.chassis_health)),
      ammo_bay_health: ModuleHealth.fromJSON(assertSet("Tank.ammo_bay_health", object.ammo_bay_health)),
      engine_health: ModuleHealth.fromJSON(assertSet("Tank.engine_health", object.engine_health)),
      fuel_tank_health: ModuleHealth.fromJSON(assertSet("Tank.fuel_tank_health", object.fuel_tank_health)),
      crew_healths: isObject(object.crew_healths)
        ? Object.entries(object.crew_healths).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      max_health: globalThis.Number(assertSet("Tank.max_health", object.max_health)),
      concealment_stationary: globalThis.Number(
        assertSet("Tank.concealment_stationary", object.concealment_stationary),
      ),
      concealment_moving: globalThis.Number(assertSet("Tank.concealment_moving", object.concealment_moving)),
      concealment_on_shot: globalThis.Number(assertSet("Tank.concealment_on_shot", object.concealment_on_shot)),
      up_pitch_limits: globalThis.Array.isArray(object?.up_pitch_limits)
        ? object.up_pitch_limits.map((e: any) => PitchLimit.fromJSON(e))
        : [],
      down_pitch_limits: globalThis.Array.isArray(object?.down_pitch_limits)
        ? object.down_pitch_limits.map((e: any) => PitchLimit.fromJSON(e))
        : [],
      turret_turn_rate: globalThis.Number(assertSet("Tank.turret_turn_rate", object.turret_turn_rate)),
      spotting_range: globalThis.Number(assertSet("Tank.spotting_range", object.spotting_range)),
      shells: globalThis.Array.isArray(object?.shells) ? object.shells.map((e: any) => Shell.fromJSON(e)) : [],
      reload_time: globalThis.Number(assertSet("Tank.reload_time", object.reload_time)),
      dispersion_stationary: globalThis.Number(assertSet("Tank.dispersion_stationary", object.dispersion_stationary)),
      dispersion_turret_rotation: globalThis.Number(
        assertSet("Tank.dispersion_turret_rotation", object.dispersion_turret_rotation),
      ),
      dispersion_moving: globalThis.Number(assertSet("Tank.dispersion_moving", object.dispersion_moving)),
      dispersion_hull_rotation: globalThis.Number(
        assertSet("Tank.dispersion_hull_rotation", object.dispersion_hull_rotation),
      ),
      gun_turn_rate: globalThis.Number(assertSet("Tank.gun_turn_rate", object.gun_turn_rate)),
      mass: globalThis.Number(assertSet("Tank.mass", object.mass)),
      engine_power: globalThis.Number(assertSet("Tank.engine_power", object.engine_power)),
      max_speed_forwards: globalThis.Number(assertSet("Tank.max_speed_forwards", object.max_speed_forwards)),
      max_speed_backwards: globalThis.Number(assertSet("Tank.max_speed_backwards", object.max_speed_backwards)),
      rotation_speed: globalThis.Number(assertSet("Tank.rotation_speed", object.rotation_speed)),
      terrain_resistance_hard: globalThis.Number(
        assertSet("Tank.terrain_resistance_hard", object.terrain_resistance_hard),
      ),
      terrain_resistance_medium: globalThis.Number(
        assertSet("Tank.terrain_resistance_medium", object.terrain_resistance_medium),
      ),
      terrain_resistance_soft: globalThis.Number(
        assertSet("Tank.terrain_resistance_soft", object.terrain_resistance_soft),
      ),
      brake_force: globalThis.Number(assertSet("Tank.brake_force", object.brake_force)),
    };
  },

  toJSON(message: Tank): unknown {
    const obj: any = {};
    if (message.turret_rotator_health !== undefined) {
      obj.turret_rotator_health = ModuleHealth.toJSON(message.turret_rotator_health);
    }
    if (message.surveying_device_health !== undefined) {
      obj.surveying_device_health = ModuleHealth.toJSON(message.surveying_device_health);
    }
    if (message.gun_health !== undefined) {
      obj.gun_health = ModuleHealth.toJSON(message.gun_health);
    }
    if (message.chassis_health !== undefined) {
      obj.chassis_health = ModuleHealth.toJSON(message.chassis_health);
    }
    if (message.ammo_bay_health !== undefined) {
      obj.ammo_bay_health = ModuleHealth.toJSON(message.ammo_bay_health);
    }
    if (message.engine_health !== undefined) {
      obj.engine_health = ModuleHealth.toJSON(message.engine_health);
    }
    if (message.fuel_tank_health !== undefined) {
      obj.fuel_tank_health = ModuleHealth.toJSON(message.fuel_tank_health);
    }
    if (message.crew_healths) {
      const entries = Object.entries(message.crew_healths);
      if (entries.length > 0) {
        obj.crew_healths = {};
        entries.forEach(([k, v]) => {
          obj.crew_healths[k] = v;
        });
      }
    }
    if (message.max_health !== 0) {
      obj.max_health = message.max_health;
    }
    if (message.concealment_stationary !== 0) {
      obj.concealment_stationary = message.concealment_stationary;
    }
    if (message.concealment_moving !== 0) {
      obj.concealment_moving = message.concealment_moving;
    }
    if (message.concealment_on_shot !== 0) {
      obj.concealment_on_shot = message.concealment_on_shot;
    }
    if (message.up_pitch_limits?.length) {
      obj.up_pitch_limits = message.up_pitch_limits.map((e) => PitchLimit.toJSON(e));
    }
    if (message.down_pitch_limits?.length) {
      obj.down_pitch_limits = message.down_pitch_limits.map((e) => PitchLimit.toJSON(e));
    }
    if (message.turret_turn_rate !== 0) {
      obj.turret_turn_rate = message.turret_turn_rate;
    }
    if (message.spotting_range !== 0) {
      obj.spotting_range = message.spotting_range;
    }
    if (message.shells?.length) {
      obj.shells = message.shells.map((e) => Shell.toJSON(e));
    }
    if (message.reload_time !== 0) {
      obj.reload_time = message.reload_time;
    }
    if (message.dispersion_stationary !== 0) {
      obj.dispersion_stationary = message.dispersion_stationary;
    }
    if (message.dispersion_turret_rotation !== 0) {
      obj.dispersion_turret_rotation = message.dispersion_turret_rotation;
    }
    if (message.dispersion_moving !== 0) {
      obj.dispersion_moving = message.dispersion_moving;
    }
    if (message.dispersion_hull_rotation !== 0) {
      obj.dispersion_hull_rotation = message.dispersion_hull_rotation;
    }
    if (message.gun_turn_rate !== 0) {
      obj.gun_turn_rate = message.gun_turn_rate;
    }
    if (message.mass !== 0) {
      obj.mass = message.mass;
    }
    if (message.engine_power !== 0) {
      obj.engine_power = message.engine_power;
    }
    if (message.max_speed_forwards !== 0) {
      obj.max_speed_forwards = message.max_speed_forwards;
    }
    if (message.max_speed_backwards !== 0) {
      obj.max_speed_backwards = message.max_speed_backwards;
    }
    if (message.rotation_speed !== 0) {
      obj.rotation_speed = message.rotation_speed;
    }
    if (message.terrain_resistance_hard !== 0) {
      obj.terrain_resistance_hard = message.terrain_resistance_hard;
    }
    if (message.terrain_resistance_medium !== 0) {
      obj.terrain_resistance_medium = message.terrain_resistance_medium;
    }
    if (message.terrain_resistance_soft !== 0) {
      obj.terrain_resistance_soft = message.terrain_resistance_soft;
    }
    if (message.brake_force !== 0) {
      obj.brake_force = message.brake_force;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tank>, I>>(base?: I): Tank {
    return Tank.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tank>, I>>(object: I): Tank {
    const message = createBaseTank();
    message.turret_rotator_health =
      (object.turret_rotator_health !== undefined && object.turret_rotator_health !== null)
        ? ModuleHealth.fromPartial(object.turret_rotator_health)
        : createBaseModuleHealth();
    message.surveying_device_health =
      (object.surveying_device_health !== undefined && object.surveying_device_health !== null)
        ? ModuleHealth.fromPartial(object.surveying_device_health)
        : createBaseModuleHealth();
    message.gun_health = (object.gun_health !== undefined && object.gun_health !== null)
      ? ModuleHealth.fromPartial(object.gun_health)
      : createBaseModuleHealth();
    message.chassis_health = (object.chassis_health !== undefined && object.chassis_health !== null)
      ? ModuleHealth.fromPartial(object.chassis_health)
      : createBaseModuleHealth();
    message.ammo_bay_health = (object.ammo_bay_health !== undefined && object.ammo_bay_health !== null)
      ? ModuleHealth.fromPartial(object.ammo_bay_health)
      : createBaseModuleHealth();
    message.engine_health = (object.engine_health !== undefined && object.engine_health !== null)
      ? ModuleHealth.fromPartial(object.engine_health)
      : createBaseModuleHealth();
    message.fuel_tank_health = (object.fuel_tank_health !== undefined && object.fuel_tank_health !== null)
      ? ModuleHealth.fromPartial(object.fuel_tank_health)
      : createBaseModuleHealth();
    message.crew_healths = Object.entries(object.crew_healths ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.max_health = object.max_health ?? 0;
    message.concealment_stationary = object.concealment_stationary ?? 0;
    message.concealment_moving = object.concealment_moving ?? 0;
    message.concealment_on_shot = object.concealment_on_shot ?? 0;
    message.up_pitch_limits = object.up_pitch_limits?.map((e) => PitchLimit.fromPartial(e)) || [];
    message.down_pitch_limits = object.down_pitch_limits?.map((e) => PitchLimit.fromPartial(e)) || [];
    message.turret_turn_rate = object.turret_turn_rate ?? 0;
    message.spotting_range = object.spotting_range ?? 0;
    message.shells = object.shells?.map((e) => Shell.fromPartial(e)) || [];
    message.reload_time = object.reload_time ?? 0;
    message.dispersion_stationary = object.dispersion_stationary ?? 0;
    message.dispersion_turret_rotation = object.dispersion_turret_rotation ?? 0;
    message.dispersion_moving = object.dispersion_moving ?? 0;
    message.dispersion_hull_rotation = object.dispersion_hull_rotation ?? 0;
    message.gun_turn_rate = object.gun_turn_rate ?? 0;
    message.mass = object.mass ?? 0;
    message.engine_power = object.engine_power ?? 0;
    message.max_speed_forwards = object.max_speed_forwards ?? 0;
    message.max_speed_backwards = object.max_speed_backwards ?? 0;
    message.rotation_speed = object.rotation_speed ?? 0;
    message.terrain_resistance_hard = object.terrain_resistance_hard ?? 0;
    message.terrain_resistance_medium = object.terrain_resistance_medium ?? 0;
    message.terrain_resistance_soft = object.terrain_resistance_soft ?? 0;
    message.brake_force = object.brake_force ?? 0;
    return message;
  },
};

function createBaseTank_CrewHealthsEntry(): Tank_CrewHealthsEntry {
  return { key: "", value: 0 };
}

export const Tank_CrewHealthsEntry: MessageFns<Tank_CrewHealthsEntry> = {
  encode(message: Tank_CrewHealthsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tank_CrewHealthsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTank_CrewHealthsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tank_CrewHealthsEntry {
    return {
      key: globalThis.String(assertSet("Tank_CrewHealthsEntry.key", object.key)),
      value: globalThis.Number(assertSet("Tank_CrewHealthsEntry.value", object.value)),
    };
  },

  toJSON(message: Tank_CrewHealthsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tank_CrewHealthsEntry>, I>>(base?: I): Tank_CrewHealthsEntry {
    return Tank_CrewHealthsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tank_CrewHealthsEntry>, I>>(object: I): Tank_CrewHealthsEntry {
    const message = createBaseTank_CrewHealthsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseShell(): Shell {
  return {
    speed: 0,
    armor_damage: 0,
    module_damage: 0,
    caliber: 0,
    penetration: 0,
    penetration_500m: 0,
    normalization: 0,
    range: 0,
    ricochet: 0,
    penetration_loss_by_distance: 0,
    explosion_radius: 0,
    max_count: 0,
  };
}

export const Shell: MessageFns<Shell> = {
  encode(message: Shell, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.speed !== 0) {
      writer.uint32(13).float(message.speed);
    }
    if (message.armor_damage !== 0) {
      writer.uint32(21).float(message.armor_damage);
    }
    if (message.module_damage !== 0) {
      writer.uint32(29).float(message.module_damage);
    }
    if (message.caliber !== 0) {
      writer.uint32(37).float(message.caliber);
    }
    if (message.penetration !== 0) {
      writer.uint32(45).float(message.penetration);
    }
    if (message.penetration_500m !== 0) {
      writer.uint32(53).float(message.penetration_500m);
    }
    if (message.normalization !== 0) {
      writer.uint32(61).float(message.normalization);
    }
    if (message.range !== 0) {
      writer.uint32(69).float(message.range);
    }
    if (message.ricochet !== 0) {
      writer.uint32(77).float(message.ricochet);
    }
    if (message.penetration_loss_by_distance !== 0) {
      writer.uint32(85).float(message.penetration_loss_by_distance);
    }
    if (message.explosion_radius !== 0) {
      writer.uint32(93).float(message.explosion_radius);
    }
    if (message.max_count !== 0) {
      writer.uint32(96).int32(message.max_count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Shell {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.speed = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.armor_damage = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.module_damage = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.caliber = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.penetration = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.penetration_500m = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.normalization = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.range = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.ricochet = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.penetration_loss_by_distance = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.explosion_radius = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.max_count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Shell {
    return {
      speed: globalThis.Number(assertSet("Shell.speed", object.speed)),
      armor_damage: globalThis.Number(assertSet("Shell.armor_damage", object.armor_damage)),
      module_damage: globalThis.Number(assertSet("Shell.module_damage", object.module_damage)),
      caliber: globalThis.Number(assertSet("Shell.caliber", object.caliber)),
      penetration: globalThis.Number(assertSet("Shell.penetration", object.penetration)),
      penetration_500m: globalThis.Number(assertSet("Shell.penetration_500m", object.penetration_500m)),
      normalization: globalThis.Number(assertSet("Shell.normalization", object.normalization)),
      range: globalThis.Number(assertSet("Shell.range", object.range)),
      ricochet: globalThis.Number(assertSet("Shell.ricochet", object.ricochet)),
      penetration_loss_by_distance: globalThis.Number(
        assertSet("Shell.penetration_loss_by_distance", object.penetration_loss_by_distance),
      ),
      explosion_radius: globalThis.Number(assertSet("Shell.explosion_radius", object.explosion_radius)),
      max_count: globalThis.Number(assertSet("Shell.max_count", object.max_count)),
    };
  },

  toJSON(message: Shell): unknown {
    const obj: any = {};
    if (message.speed !== 0) {
      obj.speed = message.speed;
    }
    if (message.armor_damage !== 0) {
      obj.armor_damage = message.armor_damage;
    }
    if (message.module_damage !== 0) {
      obj.module_damage = message.module_damage;
    }
    if (message.caliber !== 0) {
      obj.caliber = message.caliber;
    }
    if (message.penetration !== 0) {
      obj.penetration = message.penetration;
    }
    if (message.penetration_500m !== 0) {
      obj.penetration_500m = message.penetration_500m;
    }
    if (message.normalization !== 0) {
      obj.normalization = message.normalization;
    }
    if (message.range !== 0) {
      obj.range = message.range;
    }
    if (message.ricochet !== 0) {
      obj.ricochet = message.ricochet;
    }
    if (message.penetration_loss_by_distance !== 0) {
      obj.penetration_loss_by_distance = message.penetration_loss_by_distance;
    }
    if (message.explosion_radius !== 0) {
      obj.explosion_radius = message.explosion_radius;
    }
    if (message.max_count !== 0) {
      obj.max_count = Math.round(message.max_count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Shell>, I>>(base?: I): Shell {
    return Shell.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Shell>, I>>(object: I): Shell {
    const message = createBaseShell();
    message.speed = object.speed ?? 0;
    message.armor_damage = object.armor_damage ?? 0;
    message.module_damage = object.module_damage ?? 0;
    message.caliber = object.caliber ?? 0;
    message.penetration = object.penetration ?? 0;
    message.penetration_500m = object.penetration_500m ?? 0;
    message.normalization = object.normalization ?? 0;
    message.range = object.range ?? 0;
    message.ricochet = object.ricochet ?? 0;
    message.penetration_loss_by_distance = object.penetration_loss_by_distance ?? 0;
    message.explosion_radius = object.explosion_radius ?? 0;
    message.max_count = object.max_count ?? 0;
    return message;
  },
};

function createBasePitchLimit(): PitchLimit {
  return { angle: 0, value: 0 };
}

export const PitchLimit: MessageFns<PitchLimit> = {
  encode(message: PitchLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.angle !== 0) {
      writer.uint32(13).float(message.angle);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PitchLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePitchLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.angle = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PitchLimit {
    return {
      angle: globalThis.Number(assertSet("PitchLimit.angle", object.angle)),
      value: globalThis.Number(assertSet("PitchLimit.value", object.value)),
    };
  },

  toJSON(message: PitchLimit): unknown {
    const obj: any = {};
    if (message.angle !== 0) {
      obj.angle = message.angle;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PitchLimit>, I>>(base?: I): PitchLimit {
    return PitchLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PitchLimit>, I>>(object: I): PitchLimit {
    const message = createBasePitchLimit();
    message.angle = object.angle ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseModuleHealth(): ModuleHealth {
  return { max: 0, max_regen: 0, hysteresis: 0, heal_rate: 0, burn_rate: 0 };
}

export const ModuleHealth: MessageFns<ModuleHealth> = {
  encode(message: ModuleHealth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.max !== 0) {
      writer.uint32(13).float(message.max);
    }
    if (message.max_regen !== 0) {
      writer.uint32(21).float(message.max_regen);
    }
    if (message.hysteresis !== 0) {
      writer.uint32(29).float(message.hysteresis);
    }
    if (message.heal_rate !== 0) {
      writer.uint32(37).float(message.heal_rate);
    }
    if (message.burn_rate !== 0) {
      writer.uint32(45).float(message.burn_rate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModuleHealth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModuleHealth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.max = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.max_regen = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.hysteresis = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.heal_rate = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.burn_rate = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModuleHealth {
    return {
      max: globalThis.Number(assertSet("ModuleHealth.max", object.max)),
      max_regen: globalThis.Number(assertSet("ModuleHealth.max_regen", object.max_regen)),
      hysteresis: globalThis.Number(assertSet("ModuleHealth.hysteresis", object.hysteresis)),
      heal_rate: globalThis.Number(assertSet("ModuleHealth.heal_rate", object.heal_rate)),
      burn_rate: globalThis.Number(assertSet("ModuleHealth.burn_rate", object.burn_rate)),
    };
  },

  toJSON(message: ModuleHealth): unknown {
    const obj: any = {};
    if (message.max !== 0) {
      obj.max = message.max;
    }
    if (message.max_regen !== 0) {
      obj.max_regen = message.max_regen;
    }
    if (message.hysteresis !== 0) {
      obj.hysteresis = message.hysteresis;
    }
    if (message.heal_rate !== 0) {
      obj.heal_rate = message.heal_rate;
    }
    if (message.burn_rate !== 0) {
      obj.burn_rate = message.burn_rate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModuleHealth>, I>>(base?: I): ModuleHealth {
    return ModuleHealth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModuleHealth>, I>>(object: I): ModuleHealth {
    const message = createBaseModuleHealth();
    message.max = object.max ?? 0;
    message.max_regen = object.max_regen ?? 0;
    message.hysteresis = object.hysteresis ?? 0;
    message.heal_rate = object.heal_rate ?? 0;
    message.burn_rate = object.burn_rate ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

function assertSet<T>(field: string, value: T | undefined): T {
  if (!isSet(value)) {
    throw new TypeError(`Required field ${field} is not set`);
  }

  return value as T;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
