// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.2
//   protoc               v5.28.2
// source: packages/core/src/protos/legacy_model_definitions.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Vector3, createBaseVector3 } from "./utils";

export const protobufPackage = "blitzkit";

export interface ModelDefinitions {
  models: { [key: number]: ModelDefinition };
}

export interface ModelDefinitions_ModelsEntry {
  key: number;
  value: ModelDefinition | undefined;
}

export interface ModelDefinition {
  armor: Armor;
  turret_origin: Vector3;
  initial_turret_rotation?: InitialTurretRotation | undefined;
  turrets: { [key: number]: TurretModelDefinition };
  tracks: { [key: number]: TrackModelDefinition };
  bounding_box: BoundingBox;
}

export interface ModelDefinition_TurretsEntry {
  key: number;
  value: TurretModelDefinition | undefined;
}

export interface ModelDefinition_TracksEntry {
  key: number;
  value: TrackModelDefinition | undefined;
}

export interface Armor {
  thickness: { [key: number]: number };
  spaced: number[];
}

export interface Armor_ThicknessEntry {
  key: number;
  value: number;
}

export interface InitialTurretRotation {
  yaw: number;
  pitch: number;
  roll: number;
}

export interface TurretModelDefinition {
  bounding_box: BoundingBox;
  armor: Armor;
  model_id: number;
  gun_origin: Vector3;
  guns: { [key: number]: GunModelDefinition };
  yaw?: YawLimits | undefined;
}

export interface TurretModelDefinition_GunsEntry {
  key: number;
  value: GunModelDefinition | undefined;
}

export interface YawLimits {
  min: number;
  max: number;
}

export interface BoundingBox {
  min: Vector3;
  max: Vector3;
}

export interface TrackModelDefinition {
  thickness: number;
  origin: Vector3;
}

export interface GunModelDefinition {
  armor: Armor;
  thickness: number;
  model_id: number;
  pitch: PitchLimits;
  mask?: number | undefined;
}

export interface PitchLimits {
  min: number;
  max: number;
  front?: PitchLimitsExtrema | undefined;
  back?: PitchLimitsExtrema | undefined;
  transition?: number | undefined;
}

export interface PitchLimitsExtrema {
  min: number;
  max: number;
  range: number;
}

function createBaseModelDefinitions(): ModelDefinitions {
  return { models: {} };
}

export const ModelDefinitions: MessageFns<ModelDefinitions> = {
  encode(message: ModelDefinitions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.models).forEach(([key, value]) => {
      ModelDefinitions_ModelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelDefinitions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelDefinitions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = ModelDefinitions_ModelsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.models[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelDefinitions {
    return {
      models: isObject(object.models)
        ? Object.entries(object.models).reduce<{ [key: number]: ModelDefinition }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = ModelDefinition.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ModelDefinitions): unknown {
    const obj: any = {};
    if (message.models) {
      const entries = Object.entries(message.models);
      if (entries.length > 0) {
        obj.models = {};
        entries.forEach(([k, v]) => {
          obj.models[k] = ModelDefinition.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelDefinitions>, I>>(base?: I): ModelDefinitions {
    return ModelDefinitions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelDefinitions>, I>>(object: I): ModelDefinitions {
    const message = createBaseModelDefinitions();
    message.models = Object.entries(object.models ?? {}).reduce<{ [key: number]: ModelDefinition }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = ModelDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseModelDefinitions_ModelsEntry(): ModelDefinitions_ModelsEntry {
  return { key: 0, value: createBaseModelDefinition() };
}

export const ModelDefinitions_ModelsEntry: MessageFns<ModelDefinitions_ModelsEntry> = {
  encode(message: ModelDefinitions_ModelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      ModelDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelDefinitions_ModelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelDefinitions_ModelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ModelDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelDefinitions_ModelsEntry {
    return {
      key: globalThis.Number(assertSet("ModelDefinitions_ModelsEntry.key", object.key)),
      value: ModelDefinition.fromJSON(assertSet("ModelDefinitions_ModelsEntry.value", object.value)),
    };
  },

  toJSON(message: ModelDefinitions_ModelsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = ModelDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelDefinitions_ModelsEntry>, I>>(base?: I): ModelDefinitions_ModelsEntry {
    return ModelDefinitions_ModelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelDefinitions_ModelsEntry>, I>>(object: I): ModelDefinitions_ModelsEntry {
    const message = createBaseModelDefinitions_ModelsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? ModelDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseModelDefinition(): ModelDefinition {
  return {
    armor: createBaseArmor(),
    turret_origin: createBaseVector3(),
    initial_turret_rotation: undefined,
    turrets: {},
    tracks: {},
    bounding_box: createBaseBoundingBox(),
  };
}

export const ModelDefinition: MessageFns<ModelDefinition> = {
  encode(message: ModelDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.armor !== undefined) {
      Armor.encode(message.armor, writer.uint32(10).fork()).join();
    }
    if (message.turret_origin !== undefined) {
      Vector3.encode(message.turret_origin, writer.uint32(18).fork()).join();
    }
    if (message.initial_turret_rotation !== undefined) {
      InitialTurretRotation.encode(message.initial_turret_rotation, writer.uint32(26).fork()).join();
    }
    Object.entries(message.turrets).forEach(([key, value]) => {
      ModelDefinition_TurretsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.tracks).forEach(([key, value]) => {
      ModelDefinition_TracksEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.bounding_box !== undefined) {
      BoundingBox.encode(message.bounding_box, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.armor = Armor.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.turret_origin = Vector3.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.initial_turret_rotation = InitialTurretRotation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ModelDefinition_TurretsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.turrets[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = ModelDefinition_TracksEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.tracks[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bounding_box = BoundingBox.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelDefinition {
    return {
      armor: Armor.fromJSON(assertSet("ModelDefinition.armor", object.armor)),
      turret_origin: Vector3.fromJSON(assertSet("ModelDefinition.turret_origin", object.turret_origin)),
      initial_turret_rotation: isSet(object.initial_turret_rotation)
        ? InitialTurretRotation.fromJSON(object.initial_turret_rotation)
        : undefined,
      turrets: isObject(object.turrets)
        ? Object.entries(object.turrets).reduce<{ [key: number]: TurretModelDefinition }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = TurretModelDefinition.fromJSON(value);
          return acc;
        }, {})
        : {},
      tracks: isObject(object.tracks)
        ? Object.entries(object.tracks).reduce<{ [key: number]: TrackModelDefinition }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = TrackModelDefinition.fromJSON(value);
          return acc;
        }, {})
        : {},
      bounding_box: BoundingBox.fromJSON(assertSet("ModelDefinition.bounding_box", object.bounding_box)),
    };
  },

  toJSON(message: ModelDefinition): unknown {
    const obj: any = {};
    if (message.armor !== undefined) {
      obj.armor = Armor.toJSON(message.armor);
    }
    if (message.turret_origin !== undefined) {
      obj.turret_origin = Vector3.toJSON(message.turret_origin);
    }
    if (message.initial_turret_rotation !== undefined) {
      obj.initial_turret_rotation = InitialTurretRotation.toJSON(message.initial_turret_rotation);
    }
    if (message.turrets) {
      const entries = Object.entries(message.turrets);
      if (entries.length > 0) {
        obj.turrets = {};
        entries.forEach(([k, v]) => {
          obj.turrets[k] = TurretModelDefinition.toJSON(v);
        });
      }
    }
    if (message.tracks) {
      const entries = Object.entries(message.tracks);
      if (entries.length > 0) {
        obj.tracks = {};
        entries.forEach(([k, v]) => {
          obj.tracks[k] = TrackModelDefinition.toJSON(v);
        });
      }
    }
    if (message.bounding_box !== undefined) {
      obj.bounding_box = BoundingBox.toJSON(message.bounding_box);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelDefinition>, I>>(base?: I): ModelDefinition {
    return ModelDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelDefinition>, I>>(object: I): ModelDefinition {
    const message = createBaseModelDefinition();
    message.armor = (object.armor !== undefined && object.armor !== null)
      ? Armor.fromPartial(object.armor)
      : createBaseArmor();
    message.turret_origin = (object.turret_origin !== undefined && object.turret_origin !== null)
      ? Vector3.fromPartial(object.turret_origin)
      : createBaseVector3();
    message.initial_turret_rotation =
      (object.initial_turret_rotation !== undefined && object.initial_turret_rotation !== null)
        ? InitialTurretRotation.fromPartial(object.initial_turret_rotation)
        : undefined;
    message.turrets = Object.entries(object.turrets ?? {}).reduce<{ [key: number]: TurretModelDefinition }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = TurretModelDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.tracks = Object.entries(object.tracks ?? {}).reduce<{ [key: number]: TrackModelDefinition }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = TrackModelDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.bounding_box = (object.bounding_box !== undefined && object.bounding_box !== null)
      ? BoundingBox.fromPartial(object.bounding_box)
      : createBaseBoundingBox();
    return message;
  },
};

function createBaseModelDefinition_TurretsEntry(): ModelDefinition_TurretsEntry {
  return { key: 0, value: createBaseTurretModelDefinition() };
}

export const ModelDefinition_TurretsEntry: MessageFns<ModelDefinition_TurretsEntry> = {
  encode(message: ModelDefinition_TurretsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      TurretModelDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelDefinition_TurretsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelDefinition_TurretsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = TurretModelDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelDefinition_TurretsEntry {
    return {
      key: globalThis.Number(assertSet("ModelDefinition_TurretsEntry.key", object.key)),
      value: TurretModelDefinition.fromJSON(assertSet("ModelDefinition_TurretsEntry.value", object.value)),
    };
  },

  toJSON(message: ModelDefinition_TurretsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = TurretModelDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelDefinition_TurretsEntry>, I>>(base?: I): ModelDefinition_TurretsEntry {
    return ModelDefinition_TurretsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelDefinition_TurretsEntry>, I>>(object: I): ModelDefinition_TurretsEntry {
    const message = createBaseModelDefinition_TurretsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? TurretModelDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseModelDefinition_TracksEntry(): ModelDefinition_TracksEntry {
  return { key: 0, value: createBaseTrackModelDefinition() };
}

export const ModelDefinition_TracksEntry: MessageFns<ModelDefinition_TracksEntry> = {
  encode(message: ModelDefinition_TracksEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      TrackModelDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelDefinition_TracksEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelDefinition_TracksEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = TrackModelDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelDefinition_TracksEntry {
    return {
      key: globalThis.Number(assertSet("ModelDefinition_TracksEntry.key", object.key)),
      value: TrackModelDefinition.fromJSON(assertSet("ModelDefinition_TracksEntry.value", object.value)),
    };
  },

  toJSON(message: ModelDefinition_TracksEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = TrackModelDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelDefinition_TracksEntry>, I>>(base?: I): ModelDefinition_TracksEntry {
    return ModelDefinition_TracksEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelDefinition_TracksEntry>, I>>(object: I): ModelDefinition_TracksEntry {
    const message = createBaseModelDefinition_TracksEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? TrackModelDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseArmor(): Armor {
  return { thickness: {}, spaced: [] };
}

export const Armor: MessageFns<Armor> = {
  encode(message: Armor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.thickness).forEach(([key, value]) => {
      Armor_ThicknessEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    writer.uint32(18).fork();
    for (const v of message.spaced) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Armor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArmor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Armor_ThicknessEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.thickness[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.spaced.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.spaced.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Armor {
    return {
      thickness: isObject(object.thickness)
        ? Object.entries(object.thickness).reduce<{ [key: number]: number }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Number(value);
          return acc;
        }, {})
        : {},
      spaced: globalThis.Array.isArray(object?.spaced) ? object.spaced.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: Armor): unknown {
    const obj: any = {};
    if (message.thickness) {
      const entries = Object.entries(message.thickness);
      if (entries.length > 0) {
        obj.thickness = {};
        entries.forEach(([k, v]) => {
          obj.thickness[k] = v;
        });
      }
    }
    if (message.spaced?.length) {
      obj.spaced = message.spaced.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Armor>, I>>(base?: I): Armor {
    return Armor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Armor>, I>>(object: I): Armor {
    const message = createBaseArmor();
    message.thickness = Object.entries(object.thickness ?? {}).reduce<{ [key: number]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.spaced = object.spaced?.map((e) => e) || [];
    return message;
  },
};

function createBaseArmor_ThicknessEntry(): Armor_ThicknessEntry {
  return { key: 0, value: 0 };
}

export const Armor_ThicknessEntry: MessageFns<Armor_ThicknessEntry> = {
  encode(message: Armor_ThicknessEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Armor_ThicknessEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArmor_ThicknessEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Armor_ThicknessEntry {
    return {
      key: globalThis.Number(assertSet("Armor_ThicknessEntry.key", object.key)),
      value: globalThis.Number(assertSet("Armor_ThicknessEntry.value", object.value)),
    };
  },

  toJSON(message: Armor_ThicknessEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Armor_ThicknessEntry>, I>>(base?: I): Armor_ThicknessEntry {
    return Armor_ThicknessEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Armor_ThicknessEntry>, I>>(object: I): Armor_ThicknessEntry {
    const message = createBaseArmor_ThicknessEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseInitialTurretRotation(): InitialTurretRotation {
  return { yaw: 0, pitch: 0, roll: 0 };
}

export const InitialTurretRotation: MessageFns<InitialTurretRotation> = {
  encode(message: InitialTurretRotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.yaw !== 0) {
      writer.uint32(13).float(message.yaw);
    }
    if (message.pitch !== 0) {
      writer.uint32(21).float(message.pitch);
    }
    if (message.roll !== 0) {
      writer.uint32(29).float(message.roll);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitialTurretRotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialTurretRotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.yaw = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.pitch = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.roll = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialTurretRotation {
    return {
      yaw: globalThis.Number(assertSet("InitialTurretRotation.yaw", object.yaw)),
      pitch: globalThis.Number(assertSet("InitialTurretRotation.pitch", object.pitch)),
      roll: globalThis.Number(assertSet("InitialTurretRotation.roll", object.roll)),
    };
  },

  toJSON(message: InitialTurretRotation): unknown {
    const obj: any = {};
    if (message.yaw !== 0) {
      obj.yaw = message.yaw;
    }
    if (message.pitch !== 0) {
      obj.pitch = message.pitch;
    }
    if (message.roll !== 0) {
      obj.roll = message.roll;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitialTurretRotation>, I>>(base?: I): InitialTurretRotation {
    return InitialTurretRotation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitialTurretRotation>, I>>(object: I): InitialTurretRotation {
    const message = createBaseInitialTurretRotation();
    message.yaw = object.yaw ?? 0;
    message.pitch = object.pitch ?? 0;
    message.roll = object.roll ?? 0;
    return message;
  },
};

function createBaseTurretModelDefinition(): TurretModelDefinition {
  return {
    bounding_box: createBaseBoundingBox(),
    armor: createBaseArmor(),
    model_id: 0,
    gun_origin: createBaseVector3(),
    guns: {},
    yaw: undefined,
  };
}

export const TurretModelDefinition: MessageFns<TurretModelDefinition> = {
  encode(message: TurretModelDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bounding_box !== undefined) {
      BoundingBox.encode(message.bounding_box, writer.uint32(10).fork()).join();
    }
    if (message.armor !== undefined) {
      Armor.encode(message.armor, writer.uint32(18).fork()).join();
    }
    if (message.model_id !== 0) {
      writer.uint32(24).uint32(message.model_id);
    }
    if (message.gun_origin !== undefined) {
      Vector3.encode(message.gun_origin, writer.uint32(34).fork()).join();
    }
    Object.entries(message.guns).forEach(([key, value]) => {
      TurretModelDefinition_GunsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.yaw !== undefined) {
      YawLimits.encode(message.yaw, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurretModelDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurretModelDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bounding_box = BoundingBox.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.armor = Armor.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.model_id = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gun_origin = Vector3.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = TurretModelDefinition_GunsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.guns[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.yaw = YawLimits.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurretModelDefinition {
    return {
      bounding_box: BoundingBox.fromJSON(assertSet("TurretModelDefinition.bounding_box", object.bounding_box)),
      armor: Armor.fromJSON(assertSet("TurretModelDefinition.armor", object.armor)),
      model_id: globalThis.Number(assertSet("TurretModelDefinition.model_id", object.model_id)),
      gun_origin: Vector3.fromJSON(assertSet("TurretModelDefinition.gun_origin", object.gun_origin)),
      guns: isObject(object.guns)
        ? Object.entries(object.guns).reduce<{ [key: number]: GunModelDefinition }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = GunModelDefinition.fromJSON(value);
          return acc;
        }, {})
        : {},
      yaw: isSet(object.yaw) ? YawLimits.fromJSON(object.yaw) : undefined,
    };
  },

  toJSON(message: TurretModelDefinition): unknown {
    const obj: any = {};
    if (message.bounding_box !== undefined) {
      obj.bounding_box = BoundingBox.toJSON(message.bounding_box);
    }
    if (message.armor !== undefined) {
      obj.armor = Armor.toJSON(message.armor);
    }
    if (message.model_id !== 0) {
      obj.model_id = Math.round(message.model_id);
    }
    if (message.gun_origin !== undefined) {
      obj.gun_origin = Vector3.toJSON(message.gun_origin);
    }
    if (message.guns) {
      const entries = Object.entries(message.guns);
      if (entries.length > 0) {
        obj.guns = {};
        entries.forEach(([k, v]) => {
          obj.guns[k] = GunModelDefinition.toJSON(v);
        });
      }
    }
    if (message.yaw !== undefined) {
      obj.yaw = YawLimits.toJSON(message.yaw);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurretModelDefinition>, I>>(base?: I): TurretModelDefinition {
    return TurretModelDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurretModelDefinition>, I>>(object: I): TurretModelDefinition {
    const message = createBaseTurretModelDefinition();
    message.bounding_box = (object.bounding_box !== undefined && object.bounding_box !== null)
      ? BoundingBox.fromPartial(object.bounding_box)
      : createBaseBoundingBox();
    message.armor = (object.armor !== undefined && object.armor !== null)
      ? Armor.fromPartial(object.armor)
      : createBaseArmor();
    message.model_id = object.model_id ?? 0;
    message.gun_origin = (object.gun_origin !== undefined && object.gun_origin !== null)
      ? Vector3.fromPartial(object.gun_origin)
      : createBaseVector3();
    message.guns = Object.entries(object.guns ?? {}).reduce<{ [key: number]: GunModelDefinition }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = GunModelDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.yaw = (object.yaw !== undefined && object.yaw !== null) ? YawLimits.fromPartial(object.yaw) : undefined;
    return message;
  },
};

function createBaseTurretModelDefinition_GunsEntry(): TurretModelDefinition_GunsEntry {
  return { key: 0, value: createBaseGunModelDefinition() };
}

export const TurretModelDefinition_GunsEntry: MessageFns<TurretModelDefinition_GunsEntry> = {
  encode(message: TurretModelDefinition_GunsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      GunModelDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurretModelDefinition_GunsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurretModelDefinition_GunsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = GunModelDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurretModelDefinition_GunsEntry {
    return {
      key: globalThis.Number(assertSet("TurretModelDefinition_GunsEntry.key", object.key)),
      value: GunModelDefinition.fromJSON(assertSet("TurretModelDefinition_GunsEntry.value", object.value)),
    };
  },

  toJSON(message: TurretModelDefinition_GunsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = GunModelDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurretModelDefinition_GunsEntry>, I>>(base?: I): TurretModelDefinition_GunsEntry {
    return TurretModelDefinition_GunsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurretModelDefinition_GunsEntry>, I>>(
    object: I,
  ): TurretModelDefinition_GunsEntry {
    const message = createBaseTurretModelDefinition_GunsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? GunModelDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseYawLimits(): YawLimits {
  return { min: 0, max: 0 };
}

export const YawLimits: MessageFns<YawLimits> = {
  encode(message: YawLimits, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== 0) {
      writer.uint32(13).float(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(21).float(message.max);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YawLimits {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYawLimits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.min = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.max = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YawLimits {
    return {
      min: globalThis.Number(assertSet("YawLimits.min", object.min)),
      max: globalThis.Number(assertSet("YawLimits.max", object.max)),
    };
  },

  toJSON(message: YawLimits): unknown {
    const obj: any = {};
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<YawLimits>, I>>(base?: I): YawLimits {
    return YawLimits.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<YawLimits>, I>>(object: I): YawLimits {
    const message = createBaseYawLimits();
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    return message;
  },
};

function createBaseBoundingBox(): BoundingBox {
  return { min: createBaseVector3(), max: createBaseVector3() };
}

export const BoundingBox: MessageFns<BoundingBox> = {
  encode(message: BoundingBox, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== undefined) {
      Vector3.encode(message.min, writer.uint32(10).fork()).join();
    }
    if (message.max !== undefined) {
      Vector3.encode(message.max, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoundingBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoundingBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.min = Vector3.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max = Vector3.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoundingBox {
    return {
      min: Vector3.fromJSON(assertSet("BoundingBox.min", object.min)),
      max: Vector3.fromJSON(assertSet("BoundingBox.max", object.max)),
    };
  },

  toJSON(message: BoundingBox): unknown {
    const obj: any = {};
    if (message.min !== undefined) {
      obj.min = Vector3.toJSON(message.min);
    }
    if (message.max !== undefined) {
      obj.max = Vector3.toJSON(message.max);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BoundingBox>, I>>(base?: I): BoundingBox {
    return BoundingBox.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BoundingBox>, I>>(object: I): BoundingBox {
    const message = createBaseBoundingBox();
    message.min = (object.min !== undefined && object.min !== null)
      ? Vector3.fromPartial(object.min)
      : createBaseVector3();
    message.max = (object.max !== undefined && object.max !== null)
      ? Vector3.fromPartial(object.max)
      : createBaseVector3();
    return message;
  },
};

function createBaseTrackModelDefinition(): TrackModelDefinition {
  return { thickness: 0, origin: createBaseVector3() };
}

export const TrackModelDefinition: MessageFns<TrackModelDefinition> = {
  encode(message: TrackModelDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.thickness !== 0) {
      writer.uint32(13).float(message.thickness);
    }
    if (message.origin !== undefined) {
      Vector3.encode(message.origin, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackModelDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackModelDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.thickness = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.origin = Vector3.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackModelDefinition {
    return {
      thickness: globalThis.Number(assertSet("TrackModelDefinition.thickness", object.thickness)),
      origin: Vector3.fromJSON(assertSet("TrackModelDefinition.origin", object.origin)),
    };
  },

  toJSON(message: TrackModelDefinition): unknown {
    const obj: any = {};
    if (message.thickness !== 0) {
      obj.thickness = message.thickness;
    }
    if (message.origin !== undefined) {
      obj.origin = Vector3.toJSON(message.origin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackModelDefinition>, I>>(base?: I): TrackModelDefinition {
    return TrackModelDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackModelDefinition>, I>>(object: I): TrackModelDefinition {
    const message = createBaseTrackModelDefinition();
    message.thickness = object.thickness ?? 0;
    message.origin = (object.origin !== undefined && object.origin !== null)
      ? Vector3.fromPartial(object.origin)
      : createBaseVector3();
    return message;
  },
};

function createBaseGunModelDefinition(): GunModelDefinition {
  return { armor: createBaseArmor(), thickness: 0, model_id: 0, pitch: createBasePitchLimits(), mask: undefined };
}

export const GunModelDefinition: MessageFns<GunModelDefinition> = {
  encode(message: GunModelDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.armor !== undefined) {
      Armor.encode(message.armor, writer.uint32(10).fork()).join();
    }
    if (message.thickness !== 0) {
      writer.uint32(21).float(message.thickness);
    }
    if (message.model_id !== 0) {
      writer.uint32(24).uint32(message.model_id);
    }
    if (message.pitch !== undefined) {
      PitchLimits.encode(message.pitch, writer.uint32(34).fork()).join();
    }
    if (message.mask !== undefined && message.mask !== undefined) {
      writer.uint32(45).float(message.mask);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GunModelDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGunModelDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.armor = Armor.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.thickness = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.model_id = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pitch = PitchLimits.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.mask = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GunModelDefinition {
    return {
      armor: Armor.fromJSON(assertSet("GunModelDefinition.armor", object.armor)),
      thickness: globalThis.Number(assertSet("GunModelDefinition.thickness", object.thickness)),
      model_id: globalThis.Number(assertSet("GunModelDefinition.model_id", object.model_id)),
      pitch: PitchLimits.fromJSON(assertSet("GunModelDefinition.pitch", object.pitch)),
      mask: isSet(object.mask) ? globalThis.Number(object.mask) : undefined,
    };
  },

  toJSON(message: GunModelDefinition): unknown {
    const obj: any = {};
    if (message.armor !== undefined) {
      obj.armor = Armor.toJSON(message.armor);
    }
    if (message.thickness !== 0) {
      obj.thickness = message.thickness;
    }
    if (message.model_id !== 0) {
      obj.model_id = Math.round(message.model_id);
    }
    if (message.pitch !== undefined) {
      obj.pitch = PitchLimits.toJSON(message.pitch);
    }
    if (message.mask !== undefined && message.mask !== undefined) {
      obj.mask = message.mask;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GunModelDefinition>, I>>(base?: I): GunModelDefinition {
    return GunModelDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GunModelDefinition>, I>>(object: I): GunModelDefinition {
    const message = createBaseGunModelDefinition();
    message.armor = (object.armor !== undefined && object.armor !== null)
      ? Armor.fromPartial(object.armor)
      : createBaseArmor();
    message.thickness = object.thickness ?? 0;
    message.model_id = object.model_id ?? 0;
    message.pitch = (object.pitch !== undefined && object.pitch !== null)
      ? PitchLimits.fromPartial(object.pitch)
      : createBasePitchLimits();
    message.mask = object.mask ?? undefined;
    return message;
  },
};

function createBasePitchLimits(): PitchLimits {
  return { min: 0, max: 0, front: undefined, back: undefined, transition: undefined };
}

export const PitchLimits: MessageFns<PitchLimits> = {
  encode(message: PitchLimits, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== 0) {
      writer.uint32(13).float(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(21).float(message.max);
    }
    if (message.front !== undefined) {
      PitchLimitsExtrema.encode(message.front, writer.uint32(26).fork()).join();
    }
    if (message.back !== undefined) {
      PitchLimitsExtrema.encode(message.back, writer.uint32(34).fork()).join();
    }
    if (message.transition !== undefined && message.transition !== undefined) {
      writer.uint32(45).float(message.transition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PitchLimits {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePitchLimits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.min = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.max = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.front = PitchLimitsExtrema.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.back = PitchLimitsExtrema.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.transition = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PitchLimits {
    return {
      min: globalThis.Number(assertSet("PitchLimits.min", object.min)),
      max: globalThis.Number(assertSet("PitchLimits.max", object.max)),
      front: isSet(object.front) ? PitchLimitsExtrema.fromJSON(object.front) : undefined,
      back: isSet(object.back) ? PitchLimitsExtrema.fromJSON(object.back) : undefined,
      transition: isSet(object.transition) ? globalThis.Number(object.transition) : undefined,
    };
  },

  toJSON(message: PitchLimits): unknown {
    const obj: any = {};
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    if (message.front !== undefined) {
      obj.front = PitchLimitsExtrema.toJSON(message.front);
    }
    if (message.back !== undefined) {
      obj.back = PitchLimitsExtrema.toJSON(message.back);
    }
    if (message.transition !== undefined && message.transition !== undefined) {
      obj.transition = message.transition;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PitchLimits>, I>>(base?: I): PitchLimits {
    return PitchLimits.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PitchLimits>, I>>(object: I): PitchLimits {
    const message = createBasePitchLimits();
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    message.front = (object.front !== undefined && object.front !== null)
      ? PitchLimitsExtrema.fromPartial(object.front)
      : undefined;
    message.back = (object.back !== undefined && object.back !== null)
      ? PitchLimitsExtrema.fromPartial(object.back)
      : undefined;
    message.transition = object.transition ?? undefined;
    return message;
  },
};

function createBasePitchLimitsExtrema(): PitchLimitsExtrema {
  return { min: 0, max: 0, range: 0 };
}

export const PitchLimitsExtrema: MessageFns<PitchLimitsExtrema> = {
  encode(message: PitchLimitsExtrema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== 0) {
      writer.uint32(13).float(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(21).float(message.max);
    }
    if (message.range !== 0) {
      writer.uint32(29).float(message.range);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PitchLimitsExtrema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePitchLimitsExtrema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.min = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.max = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.range = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PitchLimitsExtrema {
    return {
      min: globalThis.Number(assertSet("PitchLimitsExtrema.min", object.min)),
      max: globalThis.Number(assertSet("PitchLimitsExtrema.max", object.max)),
      range: globalThis.Number(assertSet("PitchLimitsExtrema.range", object.range)),
    };
  },

  toJSON(message: PitchLimitsExtrema): unknown {
    const obj: any = {};
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    if (message.range !== 0) {
      obj.range = message.range;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PitchLimitsExtrema>, I>>(base?: I): PitchLimitsExtrema {
    return PitchLimitsExtrema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PitchLimitsExtrema>, I>>(object: I): PitchLimitsExtrema {
    const message = createBasePitchLimitsExtrema();
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    message.range = object.range ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

function assertSet<T>(field: string, value: T | undefined): T {
  if (!isSet(value)) {
    throw new TypeError(`Required field ${field} is not set`);
  }

  return value as T;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
